<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='https://oli.me.uk/' rel='self' type='application/rss+xml'/>
<title>
(ollie {:on :parens})
</title>
<link>
https://oli.me.uk/
</link>
<description>
On languages and text editors.
</description>
<lastBuildDate>
Mon, 26 Feb 2018 21:41:43 +0000
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
https://oli.me.uk/posts-output/2018-02-26-clojure-projects-from-scratch/
</guid>
<link>
https://oli.me.uk/posts-output/2018-02-26-clojure-projects-from-scratch/
</link>
<title>
Clojure projects from scratch
</title>
<description>
&lt;p&gt;This post is intended &lt;i&gt;primarily&lt;/i&gt; for two groups of people:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;People just starting out in Clojure, who know parts of the language but don't know how to begin structuring a real project.&lt;/li&gt;&lt;li&gt;Seasoned Clojurians who wish to see how to structure a project with the new Clojure CLI + &lt;code&gt;deps.edn&lt;/code&gt; and not &lt;code&gt;lein&lt;/code&gt; or &lt;code&gt;boot&lt;/code&gt; (even though they're still awesome).&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;My goal is to teach you how to go from an empty directory, to a project you can run, test, compile and (if you wish to) publish with ease. We're going to get there through a series of relatively small steps so you can understand all the tools you're using.&lt;/p&gt;&lt;p&gt;There won't be an awful lot of Clojure code here, so don't worry if you're still getting your head around the language itself. The only code example will be a &quot;Hello, World!&quot;, if that helps.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; Note: This post assumes usage of Linux, OSX or similar, I'm afraid it isn't intended for Windows users since I just don't have the knowledge to help you there. Some of the information will apply, but you'll have to adapt things, I'm sure you can find Windows specific guides for the parts that don't fit. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;I'm not going into what editor you should use because that's a book in itself. If you're totally at a loss, check out &lt;a href=''&gt;Cursive&lt;/a&gt;, although I use &lt;a href=''&gt;Spacemacs&lt;/a&gt; because I can't survive without good Vim emulation. There's probably a great plugin for your editor of choice and instructions on getting started, have a Google.&lt;/p&gt;&lt;p&gt;A lot of what I'm going to be talking about can be found in practice in &lt;a href='https://github.com/robert-stuttaford/bridge'&gt;github.com/robert-stuttaford/bridge&lt;/a&gt;, you may want to have a peruse at some point.&lt;/p&gt;&lt;h2 id=&quot;installing&amp;#95;the&amp;#95;clojure&amp;#95;cli&quot;&gt;Installing the Clojure CLI&lt;/h2&gt;&lt;p&gt;To run Clojure you'll need the command line tool (introduced around the time of Clojure 1.9) that manages dependencies and allows you execute code.&lt;/p&gt;&lt;p&gt;If you're on OSX, you can use &lt;code&gt;brew&lt;/code&gt; to install the CLI.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ brew install clojure
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I have found that I could install it through the Arch Linux package manager although it was slightly out of date at the time of writing, so I don't recommend this just yet. If you're on Linux you can run the manual installer easily enough.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ curl -O https://download.clojure.org/install/linux-install-1.9.0.326.sh
$ sudo bash linux-install-1.9.0.326.sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To update, use the package manager you used for the installation or find the latest Linux installer URL on the &lt;a href='https://clojure.org/guides/getting_started'&gt;getting started&lt;/a&gt; page.&lt;/p&gt;&lt;p&gt;You should now be able to drop into a Clojure REPL with one command. You can run &lt;code&gt;clojure&lt;/code&gt; or &lt;code&gt;clj&lt;/code&gt; in your terminal, the latter has a slightly better editing experience but requires you to have &lt;code&gt;rlwrap&lt;/code&gt; installed.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj
Clojure 1.9.0
user=&amp;gt; &amp;#40;+ 10 15&amp;#41;
25
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;initial&amp;#95;files&quot;&gt;Initial files&lt;/h2&gt;&lt;p&gt;Presuming our project is called &lt;code&gt;hey&lt;/code&gt;, let's go ahead and create these directories and files:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ mkdir -p hey/{src/hey,test/hey}
$ cd hey
$ touch src/hey/core.clj test/hey/core&amp;#95;test.clj
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This provides us with the following directory structure:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ tree
.
├── src
│   └── hey
│       └── core.clj
└── test
    └── hey
        └── core&amp;#95;test.clj

4 directories, 2 files
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let's insert some content into these files:&lt;/p&gt;&lt;h3 id=&quot;src/hey/core.clj&quot;&gt;src/hey/core.clj&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns hey.core&amp;#41;

&amp;#40;defn -main &amp;#91;&amp;#93;
  &amp;#40;println &amp;quot;Hello, World!&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;test/hey/core&amp;#95;test.clj&quot;&gt;test/hey/core&amp;#95;test.clj&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns hey.core-test
  &amp;#40;:require &amp;#91;clojure.test :as t&amp;#93;
            &amp;#91;hey.core :as sut&amp;#93;&amp;#41;&amp;#41;

&amp;#40;t/deftest basic-tests
  &amp;#40;t/testing &amp;quot;it says hello to everyone&amp;quot;
    &amp;#40;t/is &amp;#40;= &amp;#40;with-out-str &amp;#40;sut/-main&amp;#41;&amp;#41; &amp;quot;Hello, World!\n&amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The main namespace simply prints &quot;Hello, World!&quot; when executed and the test confirms that functionality.&lt;/p&gt;&lt;h2 id=&quot;running&amp;#95;your&amp;#95;code&quot;&gt;Running your code&lt;/h2&gt;&lt;p&gt;Now that we have a bare bones program and test file in our project directory, we're probably going to want to run it. We can do that with the Clojure CLI, go ahead and execute the following:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj -m hey.core
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You should see &quot;Hello, World!&quot; printed in your terminal. Let's try jumping into a REPL so we can interact with our code directly:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj
Clojure 1.9.0
user=&amp;gt; &amp;#40;load &amp;quot;hey/core&amp;quot;&amp;#41;
nil
user=&amp;gt; &amp;#40;in-ns 'hey.core&amp;#41;
#object&amp;#91;clojure.lang.Namespace 0x2072acb2 &amp;quot;hey.core&amp;quot;&amp;#93;
hey.core=&amp;gt; &amp;#40;-main&amp;#41;
Hello, World!
nil
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If your editor supports Clojure, you can probably connect a REPL and interact with your code through there too. With spacemacs I would type &lt;code&gt;,'&lt;/code&gt; to &quot;jack in&quot; with CIDER. I can then use &lt;code&gt;,ee&lt;/code&gt; to evaluate expressions as I work.&lt;/p&gt;&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;&lt;p&gt;We have a test file but no way to run it. We could create our own test runner namespace that executed &lt;code&gt;clojure.test/run-all-tests&lt;/code&gt;, but that requires telling it about every testing namespace we have in our project. It gets tedious after a while, so let's get something that does it for us.&lt;/p&gt;&lt;p&gt;Create a file called &lt;code&gt;deps.edn&lt;/code&gt; at the top of your project and add the following to it:&lt;/p&gt;&lt;h3 id=&quot;deps.edn&quot;&gt;deps.edn&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:paths &amp;#91;&amp;quot;src&amp;quot;&amp;#93;

 :deps
 {org.clojure/clojure {:mvn/version &amp;quot;1.9.0&amp;quot;}}

 :aliases
 {:test
  {:extra-paths &amp;#91;&amp;quot;test&amp;quot;&amp;#93;
   :extra-deps
   {com.cognitect/test-runner {:git/url &amp;quot;git@github.com:cognitect-labs/test-runner&amp;quot;
                               :sha &amp;quot;5f2b5c2efb444df76fb5252102b33f542ebf7f58&amp;quot;}}
   :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;cognitect.test-runner&amp;quot;&amp;#93;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let's break this down:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;:paths&lt;/code&gt; tells Clojure where to look for our source files.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:deps&lt;/code&gt; is where we specify our dependencies, right now all we're depending on is Clojure 1.9.0.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:aliases&lt;/code&gt; is where we specify special overrides that we can apply with the &lt;code&gt;-A&lt;/code&gt; argument to the CLI.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:test&lt;/code&gt; is the name of our alias, it adds the &lt;code&gt;test&lt;/code&gt; directory to the paths list and &lt;code&gt;com.cognitect/test-runner&lt;/code&gt; to the dependencies.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:main-opts&lt;/code&gt; instructs Clojure that we want these arguments applied when the alias is active. In this case, we're using &lt;code&gt;-m&lt;/code&gt; to specify which namespace to execute.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The usage of &lt;code&gt;deps.edn&lt;/code&gt; is documented further in &lt;a href='https://clojure.org/guides/deps_and_cli'&gt;the deps guide&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;This will discover and run our test for us, let's run it now:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj -Atest

Running tests in #{&amp;quot;test&amp;quot;}

Testing hey.core-test

Ran 1 tests containing 1 assertions.
0 failures, 0 errors.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Hopefully you see the same success message as myself. You can see that we applied the values specified in our alias with the &lt;code&gt;-Atest&lt;/code&gt; argument.&lt;/p&gt;&lt;h2 id=&quot;building&amp;#95;jars&quot;&gt;Building jars&lt;/h2&gt;&lt;p&gt;You can now write additional namespaces, add dependencies, run your code and test things. You've actually got a lot of what you need already and with very little tooling or configuration. Eventually you're going to want to build a jar to either publish for others to use (in the case of a library) or run on a server (in the case of an application).&lt;/p&gt;&lt;p&gt;Compiling your project into a jar will involve similar steps to getting your tests running, we're going to add another alias with another dependency which does the job for us.&lt;/p&gt;&lt;p&gt;Go ahead and add this new alias to the &lt;code&gt;:aliases&lt;/code&gt; section of your &lt;code&gt;deps.edn&lt;/code&gt; file, next to the &lt;code&gt;:test&lt;/code&gt; alias:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:pack
{:extra-deps
 {pack/pack.alpha
  {:git/url &amp;quot;git@github.com:juxt/pack.alpha.git&amp;quot;
   :sha     &amp;quot;e6d0691c5f58135e1ef6fb1c9dda563611d36205&amp;quot;}}
 :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;mach.pack.alpha.capsule&amp;quot; &amp;quot;deps.edn&amp;quot; &amp;quot;dist/hey.jar&amp;quot;&amp;#93;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now build a jar that we can execute directly through the &lt;code&gt;java&lt;/code&gt; program, without the Clojure CLI:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj -Apack
$ java -jar dist/hey.jar # Drop us into a Clojure REPL.
$ java -jar dist/hey.jar -m hey.core # Executes our &amp;quot;Hello, World!&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;publishing&quot;&gt;Publishing&lt;/h2&gt;&lt;p&gt;Now that you have your jar built you have a couple of options with regards to getting it out into the world. You may want to simply deploy your jar, possibly within a Docker container, to your own server. This is the route you'll take if you're building some sort of web application.&lt;/p&gt;&lt;p&gt;Alternatively, you may have written a library that you wish to publish onto &lt;a href=''&gt;Clojars&lt;/a&gt; for anyone to use, we're going to use maven to accomplish this.&lt;/p&gt;&lt;p&gt;First, we're going to add your Clojars login to &lt;code&gt;&amp;#126;/.m2/settings.xml&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;settings&amp;gt;
  &amp;lt;servers&amp;gt;
    &amp;lt;server&amp;gt;
      &amp;lt;id&amp;gt;clojars&amp;lt;/id&amp;gt;
      &amp;lt;username&amp;gt;username&amp;lt;/username&amp;gt;
      &amp;lt;password&amp;gt;password&amp;lt;/password&amp;gt;
    &amp;lt;/server&amp;gt;
  &amp;lt;/servers&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we're going to generate your base &lt;code&gt;pom.xml&lt;/code&gt; file, you should run this command whenever you're going to publish so the dependencies get updated:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj -Spom
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here's my example version, it contains some extra Clojars specific fields that you may want to use:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  &amp;lt;groupId&amp;gt;org.clojars.olical&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;hey&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;name&amp;gt;hey&amp;lt;/name&amp;gt;
  &amp;lt;description&amp;gt;Just a Hello, World!&amp;lt;/description&amp;gt;
  &amp;lt;url&amp;gt;https://github.com/Olical/clojure-hey-example&amp;lt;/url&amp;gt;
  &amp;lt;licenses&amp;gt;
    &amp;lt;license&amp;gt;
      &amp;lt;name&amp;gt;Unlicense&amp;lt;/name&amp;gt;
      &amp;lt;url&amp;gt;https://unlicense.org/&amp;lt;/url&amp;gt;
    &amp;lt;/license&amp;gt;
  &amp;lt;/licenses&amp;gt;
  &amp;lt;scm&amp;gt;
    &amp;lt;url&amp;gt;https://github.com/Olical/clojure-hey-example&amp;lt;/url&amp;gt;
  &amp;lt;/scm&amp;gt;
  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.clojure&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;clojure&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.9.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;
  &amp;lt;build&amp;gt;
    &amp;lt;sourceDirectory&amp;gt;src&amp;lt;/sourceDirectory&amp;gt;
  &amp;lt;/build&amp;gt;
  &amp;lt;repositories&amp;gt;
    &amp;lt;repository&amp;gt;
      &amp;lt;id&amp;gt;clojars&amp;lt;/id&amp;gt;
      &amp;lt;url&amp;gt;https://clojars.org/repo&amp;lt;/url&amp;gt;
    &amp;lt;/repository&amp;gt;
  &amp;lt;/repositories&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now tell maven to deploy our built jar using this pom file:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ mvn deploy:deploy-file \
   -DpomFile=pom.xml \
   -Dfile=dist/hey.jar \
   -DrepositoryId=clojars \
   -Durl=https://clojars.org/repo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A lot of this information comes from &lt;a href='https://github.com/clojars/clojars-web/wiki/Pushing'&gt;Clojar's guide to pushing&lt;/a&gt; and &lt;a href='https://maven.apache.org/guides/mini/guide-3rd-party-jars-remote.html'&gt;Maven's guide to deploying 3rd party jars&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;If everything went to plan, your Clojars account should now contain a fresh new jar.&lt;/p&gt;&lt;h2 id=&quot;ergonomics&quot;&gt;Ergonomics&lt;/h2&gt;&lt;p&gt;As it stands, to deploy our jar to Clojars we'll want to take the following steps:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Run the tests with &lt;code&gt;clj -Atest&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;Build a fresh jar with &lt;code&gt;clj -Apack&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;Run &lt;code&gt;clj -Spom&lt;/code&gt; to update our &lt;code&gt;pom.xml&lt;/code&gt; with any dependency changes. (this may require some manual XML grooming)&lt;/li&gt;&lt;li&gt;Update the version number in our &lt;code&gt;pom.xml&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;Run the &lt;code&gt;mvn deploy:deploy-file...&lt;/code&gt; command. &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This isn't particularly catchy, so we'll wrap everything we've seen so far in a pretty little &lt;code&gt;Makefile&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;makefile&quot;&gt;.PHONY: run test pack deploy

run:
	clj -m hey.core

test:
	clj -Atest

pack:
	clj -Apack

deploy: test pack
	clj -Spom
	mvn deploy:deploy-file \
		-DpomFile=pom.xml \
		-Dfile=dist/hey.jar \
		-DrepositoryId=clojars \
		-Durl=https://clojars.org/repo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now all you need to do when you wish to deploy is bump the version number in your &lt;code&gt;pom.xml&lt;/code&gt; and execute &lt;code&gt;make deploy&lt;/code&gt;.&lt;/p&gt;&lt;h2 id=&quot;thanks!&quot;&gt;Thanks!&lt;/h2&gt;&lt;p&gt;If you've got this far I really hoped this post has helped you out. You can find the example project I built during the writing of this post at &lt;a href='https://github.com/Olical/clojure-hey-example'&gt;github.com/Olical/clojure-hey-example&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Happy Clojuring!&lt;/p&gt;
</description>
<pubDate>
Mon, 26 Feb 2018 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/posts-output/2017-10-27-hello-world/
</guid>
<link>
https://oli.me.uk/posts-output/2017-10-27-hello-world/
</link>
<title>
Hello, World!
</title>
<description>
&lt;p&gt;I've, once again, migrated my blog onto another platform. This time I've gone from WordPress on my own Linode to &lt;a href=&quot;&quot;&gt;Cryogen&lt;/a&gt; on GitHub pages. This means a few things:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;I no longer need to worry about running my own server, even though Linode is fantastic. I just don't want to maintain anything, especially WordPress.&lt;/li&gt;&lt;li&gt;I can blog with a Clojure based platform and integrate &lt;a href=&quot;&quot;&gt;Klipse&lt;/a&gt; easily for interactive lispy posts.&lt;/li&gt;&lt;li&gt;I can write my posts in markdown with Emacs and keep it all on &lt;a href=&quot;https://github.com/Olical/olical.github.io&quot;&gt;GitHub&lt;/a&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;the_migration&quot;&gt;The migration&lt;/h2&gt; &lt;p&gt;I wanted to start fresh since my old blog is full of so many topics that I do not feel reflect my true interests anymore, so here I am with a blank slate. Luckily I found a way to keep my WordPress site exactly how it was so as not to break a single URL without running WordPress itself.&lt;/p&gt;&lt;p&gt;I used &lt;a href=&quot;https://en-gb.wordpress.org/plugins/simply-static/&quot;&gt;Simply Static&lt;/a&gt; to generate a snapshot of my entire blog which I could then merge into my GitHub pages repositories top level. This means every URL that used to work with my original blog will work with this one.&lt;/p&gt;&lt;p&gt;I don't promote my old posts through this anymore, but they're still there, I even preserved &lt;a href=&quot;https://oli.me.uk/wp-index.html&quot;&gt;the original homepage&lt;/a&gt;.&lt;/p&gt;&lt;h2 id=&quot;the_payoff&quot;&gt;The payoff&lt;/h2&gt;&lt;p&gt;I think it was worth it since I no longer have to run a server and I can do things like this.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-scheme nohighlight&quot;&gt;(define (add a b)
  (if (= b 0)
    a
    (add (+ a 1) (- b 1))))
    
(add 10 20)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I also did this entire migration today while on trains and in cars over mobile internet, which was fun.&lt;/p&gt;
</description>
<pubDate>
Fri, 27 Oct 2017 00:00:00 +0100
</pubDate>
</item>
</channel>
</rss>
