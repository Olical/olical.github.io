<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='https://oli.me.uk/' rel='self' type='application/rss+xml'/>
<title>
(ollie {:on :parens})
</title>
<link>
https://oli.me.uk/
</link>
<description>
On languages and text editors.
</description>
<lastBuildDate>
Thu, 24 May 2018 16:23:18 +0100
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
https://oli.me.uk/2018-05-04-editing-clojure-with-neovim/
</guid>
<link>
https://oli.me.uk/2018-05-04-editing-clojure-with-neovim/
</link>
<title>
Editing Clojure with Neovim
</title>
<description>
&lt;p&gt;I've used &lt;a href='http://spacemacs.org/'&gt;Spacemacs&lt;/a&gt; since I started working with &lt;a href='https://clojure.org/'&gt;Clojure&lt;/a&gt; a few years ago, it's an extremely powerful system on par with full IDEs such as &lt;a href='https://cursive-ide.com/'&gt;Cursive&lt;/a&gt;. I highly recommend either of these tools to the budding Clojure(Script) developer, they will carry you as far as you need to go and beyond.&lt;/p&gt;&lt;p&gt;The reason I have drifted back to &lt;a href='https://www.vim.org/'&gt;Vim&lt;/a&gt; (&lt;a href='https://neovim.io/'&gt;Neovim&lt;/a&gt; specifically) is because I never felt quite at home within &lt;a href='https://www.gnu.org/software/emacs/'&gt;Emacs&lt;/a&gt;, which Spacemacs is built upon. I wrote JavaScript (among other languages) in Vim for around five years before I began really studying Clojure. Vim and it's nuances are pretty deeply buried within my brain and muscle memory (if that's actually a thing).&lt;/p&gt;&lt;p&gt;I've been working on a fresh Neovim setup in my &lt;a href='https://github.com/Olical/dotfiles'&gt;dotfiles&lt;/a&gt; repository and I'm finally at a point where I'm happy with it for day to day work. I extracted my current setup into &lt;a href='https://github.com/Olical/spacy-neovim'&gt;spacy-neovim&lt;/a&gt; for others to fork and build upon in their own repositories. It acts as an opinionated starting point modeled after Spacemacs that you're expected to modify to fit your needs.&lt;/p&gt;&lt;p&gt;This post will mainly be describing the approach I'm taking in my dotfiles and the spacy-neovim repository.&lt;/p&gt;&lt;h2 id=&quot;structure&quot;&gt;Structure&lt;/h2&gt;&lt;p&gt;The layout of my configuration is almost identical to my previous JavaScript setup:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;There's a top level entry point: &lt;code&gt;init.vim&lt;/code&gt;, it sources every file in the &lt;code&gt;modules/&lt;/code&gt; directory.&lt;/li&gt;&lt;li&gt;A file in the root directory, &lt;code&gt;plugins.vim&lt;/code&gt;, simply lists all of my dependencies for &lt;a href='https://github.com/junegunn/vim-plug'&gt;vim-plug&lt;/a&gt; to handle.&lt;/li&gt;&lt;li&gt;The &lt;code&gt;modules/&lt;/code&gt; directory contains different configuration related files.&lt;ul&gt;&lt;li&gt;&lt;code&gt;modules/core.vim&lt;/code&gt; - Super basic and general configuration for the entire editor.&lt;/li&gt;&lt;li&gt;&lt;code&gt;modules/mappings.vim&lt;/code&gt; - Custom mappings for things like closing hidden buffers or trimming whitespace.&lt;/li&gt;&lt;li&gt;&lt;code&gt;modules/plugins.vim&lt;/code&gt; - Activates vim-plug and loads configuration files for those plugins. It also warns you if you've remove a plugin but not the configuration file on startup.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Plugin configuration files are found in &lt;code&gt;modules/plugins/&lt;/code&gt;, like &lt;code&gt;modules/plugins/vim-fireplace.vim&lt;/code&gt;. They set plugins up and define useful bindings to access their functionality.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Speaking of which, let's have a tour of some of the most important plugins that are included.&lt;/p&gt;&lt;h2 id=&quot;plugins&quot;&gt;Plugins&lt;/h2&gt;&lt;h3 id=&quot;&lt;a href='https://github.com/tpope/vim-fireplace'&gt;tpope/vim-fireplace&lt;/a&gt;&quot;&gt;&lt;a href='https://github.com/tpope/vim-fireplace'&gt;tpope/vim-fireplace&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;This is essential. If you wish to edit Clojure within Vim you'll need this plugin above all others, it gives you a way to interact with and evaluate your Clojure code via an &lt;a href='https://github.com/clojure-emacs/cider-nrepl'&gt;nREPL&lt;/a&gt; connection.&lt;/p&gt;&lt;p&gt;I've defined the following bindings in &lt;code&gt;modules/plugins/vim-fireplace.vim&lt;/code&gt;, they make using it feel a little more like &lt;a href='https://github.com/clojure-emacs/cider'&gt;CIDER&lt;/a&gt; (The Clojure Interactive Development Environment that Rocks for Emacs).&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;viml&quot;&gt;autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;re :Eval&amp;lt;cr&amp;gt;
autocmd FileType clojure vnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;re :Eval&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;rf :%Eval&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;rr :Require&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;rR :Require!&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;rt :RunTests&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;rl :Last&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;rc :FireplaceConnect&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; gd :normal &amp;#91;&amp;lt;c-d&amp;gt;&amp;lt;cr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;My &lt;code&gt;localleader&lt;/code&gt; is set to &lt;code&gt;,&lt;/code&gt; so I usually hit &lt;code&gt;,rc&lt;/code&gt; to connect to a REPL then a mixture of &lt;code&gt;cpp&lt;/code&gt; to evaluate the innermost form and &lt;code&gt;,re&lt;/code&gt; to evaluate the outermost.&lt;/p&gt;&lt;p&gt;I encountered some features I missed from CIDER, namely being able to reload every namespace and reboot the system with a single binding. I also created some bindings to automatically connect to my API and UI REPLs at work, I have this &lt;code&gt;.lvimrc&lt;/code&gt; defined within my work repo.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;viml&quot;&gt;autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; &amp;lt;localleader&amp;gt;rA :FireplaceConnect nrepl://localhost:9001 %{getcwd&amp;#40;&amp;#41;}&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; &amp;lt;localleader&amp;gt;rU :FireplaceConnect nrepl://localhost:9002 %{getcwd&amp;#40;&amp;#41;}&amp;lt;cr&amp;gt;:e dev/user.clj&amp;lt;cr&amp;gt;:Eval &amp;#40;cljs-repl&amp;#41;&amp;lt;cr&amp;gt;:bd&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; &amp;lt;localleader&amp;gt;rx :Eval &amp;#40;do &amp;#40;require 'clojure.tools.namespace.repl&amp;#41; &amp;#40;bounce.system/stop!&amp;#41; &amp;#40;clojure.tools.namespace.repl/set-refresh-dirs &amp;quot;src/clj&amp;quot; &amp;quot;src/cljc&amp;quot;&amp;#41; &amp;#40;clojure.tools.namespace.repl/refresh :after 'bounce.system/start!&amp;#41;&amp;#41;&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; &amp;lt;localleader&amp;gt;rX :Eval &amp;#40;do &amp;#40;require 'clojure.tools.namespace.repl&amp;#41; &amp;#40;bounce.system/stop!&amp;#41; &amp;#40;clojure.tools.namespace.repl/clear&amp;#41; &amp;#40;clojure.tools.namespace.repl/set-refresh-dirs &amp;quot;src/clj&amp;quot; &amp;quot;src/cljc&amp;quot;&amp;#41; &amp;#40;clojure.tools.namespace.repl/refresh-all :after 'bounce.system/start!&amp;#41;&amp;#41;&amp;lt;cr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;,rA&lt;/code&gt; connects me to my API REPL.&lt;/li&gt;&lt;li&gt;&lt;code&gt;,rU&lt;/code&gt; connects me to the UI REPL and evaluates the figwheel piggieback code to hook it up to my browser.&lt;/li&gt;&lt;li&gt;&lt;code&gt;,rx&lt;/code&gt; shuts the system down, reloads changed namespaces and starts it back up.&lt;/li&gt;&lt;li&gt;&lt;code&gt;,rX&lt;/code&gt; shuts the system down, reloads &lt;i&gt;every&lt;/i&gt; namespace and starts it back up.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Once I have my API or UI REPL connection up all evaluation and autocompletion works for the given context, so that'll either be Clojure or ClojureScript. I can only have one connection at a time, but that connection works really damn well.&lt;/p&gt;&lt;h3 id=&quot;&lt;a href='https://github.com/guns/vim-sexp'&gt;guns/vim-sexp&lt;/a&gt;&quot;&gt;&lt;a href='https://github.com/guns/vim-sexp'&gt;guns/vim-sexp&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;a href='https://github.com/easymotion/vim-easymotion'&gt;EasyMotion&lt;/a&gt; is still my favourite way to navigate but vim-sexp is my favourite way to edit. I use it in place of &lt;a href='https://github.com/sp3ctum/evil-lispy'&gt;evil-lispy&lt;/a&gt; in Emacs to manipulate s-expressions.&lt;/p&gt;&lt;p&gt;The default bindings involve holding down a few modifiers like &lt;code&gt;ctrl&lt;/code&gt; and &lt;code&gt;alt&lt;/code&gt; and pressing a mixture of &lt;code&gt;hjkl&lt;/code&gt; keys which I actually quite like. I still have &lt;a href='https://github.com/tpope/vim-sexp-mappings-for-regular-people'&gt;vim-sexp-mappings-for-regular-people&lt;/a&gt; installed but I've found myself using it less and less as I learn the extensive bindings of vim-sexp.&lt;/p&gt;&lt;p&gt;Maybe my slightly esoteric custom ErgoDox keyboard layout makes that easier than the bindings are on a regular keyboard. Luckily tpope's enhancement plugin provides more than a couple of simple rebindings so I'd highly recommend you use it even if you don't mind the meta key shenanigans.&lt;/p&gt;&lt;h3 id=&quot;so&amp;#95;many&amp;#95;more&quot;&gt;So many more&lt;/h3&gt;&lt;p&gt;The best way to explore this setup is to skim the README in &lt;a href='https://github.com/Olical/spacy-neovim'&gt;spacy-neovim&lt;/a&gt; as well as browse the source (which is pretty short). I list a few more of the features and link to their configuration source in the repository, you may find that useful.&lt;/p&gt;&lt;h2 id=&quot;:wq&quot;&gt;:wq&lt;/h2&gt;&lt;p&gt;I hope this repository helps you to get started with your own Neovim and Clojure editor setup. If you've tried Cursive and Spacemacs but decided it's not for you and you need to return to Vim I'm here to tell you that's it's totally possible.&lt;/p&gt;&lt;p&gt;Use what I've made as a starting point to get a bunch of low hanging fruit out of the way then customise your editor to your needs.&lt;/p&gt;&lt;p&gt;Feel free to reach out to me in the comments or on twitter (&lt;a href='https://twitter.com/OliverCaldwell'&gt;@OliverCaldwell&lt;/a&gt;) if you have any questions or insights for me.&lt;/p&gt;
</description>
<pubDate>
Fri, 04 May 2018 00:00:00 +0100
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2018-03-29-finding-new-dependencies-with-depot/
</guid>
<link>
https://oli.me.uk/2018-03-29-finding-new-dependencies-with-depot/
</link>
<title>
Finding new dependencies with Depot
</title>
<description>
&lt;p&gt;If you're using lein you can use lein-ancient to find newer versions of your dependencies, if you're using boot you probably have something similar. With the Clojure CLI however you have to keep track of these things manually.&lt;/p&gt;&lt;p&gt;I've created a little tool called &lt;a href='https://github.com/Olical/depot'&gt;Depot&lt;/a&gt; that aims to give you this same new version detection for your &lt;code&gt;deps.edn&lt;/code&gt; file. The README is probably enough to get you going but here's a little example anyway.&lt;/p&gt;&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;&lt;p&gt;You'll want to add Depot to your &lt;code&gt;deps.edn&lt;/code&gt; file, you can do this at the project level or within your user-wide file at &lt;code&gt;&amp;#126;/.clojure/deps.edn&lt;/code&gt;. I'd recommend you add it at a project level however since this'll allow anyone working on your codebase to use the same tooling, especially if it's wrapped up in a &lt;code&gt;Makefile&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:deps {org.clojure/clojure {:mvn/version &amp;quot;1.9.0&amp;quot;}
        org.clojure/clojurescript {:mvn/version &amp;quot;1.10.238&amp;quot;}}
 :aliases {:outdated {:extra-deps {olical/depot {:mvn/version &amp;quot;1.0.1&amp;quot;}}
                      :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;depot.outdated.main&amp;quot;&amp;#93;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now execute Depot by referring to our alias:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clojure -Aoutdated
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At the time of writing this doesn't output anything since everything's up to date. If we were to depend on, say, ClojureScript 1.9.946 however:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clojure -Aoutdated
org.clojure/clojurescript: 1.9.946 =&amp;gt; 1.10.238
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we're also depending on Depot 1.0.0, as opposed to the currently released 1.0.1, we could even have it check it's own alias:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clojure -Aoutdated --aliases outdated
org.clojure/clojurescript: 1.9.946 =&amp;gt; 1.10.238
olical/depot: 1.0.0 =&amp;gt; 1.0.1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can also ask it to consider non-release versions such as snapshots and qualified versions such as alphas. This will pick the very latest version, regardless of stability:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clojure -Aoutdated --aliases outdated --consider-types qualified,release,snapshot
org.clojure/clojure: 1.9.0 =&amp;gt; 1.10.0-alpha4
org.clojure/clojurescript: 1.9.946 =&amp;gt; 1.10.238
olical/depot: 1.0.0 =&amp;gt; 1.0.1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I hope you find Depot useful in keeping your dependencies up to date.&lt;/p&gt;
</description>
<pubDate>
Thu, 29 Mar 2018 00:00:00 +0100
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2018-03-29-clojure-and-clojurescript-tests-on-travis/
</guid>
<link>
https://oli.me.uk/2018-03-29-clojure-and-clojurescript-tests-on-travis/
</link>
<title>
Clojure and ClojureScript tests on Travis
</title>
<description>
&lt;p&gt;As far as I can tell, there isn't a canonical way to run your Clojure(Script) tests on &lt;a href='http://travis-ci.org/'&gt;Travis&lt;/a&gt; through the Clojure CLI. I think it's slightly easier for those of you using &lt;code&gt;lein&lt;/code&gt;, but here's how to do it with &lt;code&gt;clj&lt;/code&gt;.&lt;/p&gt;&lt;h2 id=&quot;dependencies&quot;&gt;Dependencies&lt;/h2&gt;&lt;p&gt;You'll need a couple of deps to execute your tests, here's an example &lt;code&gt;deps.edn&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:deps {org.clojure/clojure {:mvn/version &amp;quot;1.9.0&amp;quot;}
        org.clojure/clojurescript {:mvn/version &amp;quot;1.10.238&amp;quot;} }
 :aliases {:test-clj {:extra-paths &amp;#91;&amp;quot;test&amp;quot;&amp;#93;
                      :extra-deps {com.cognitect/test-runner {:git/url &amp;quot;https://github.com/Olical/test-runner.git&amp;quot;
                                                              :sha &amp;quot;7c4f5bd4987ec514889c7cd7e3d13f4ef95f256b&amp;quot;}}
                      :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;cognitect.test-runner&amp;quot;&amp;#93;}
           :test-cljs {:extra-deps {olical/cljs-test-runner {:mvn/version &amp;quot;0.1.1&amp;quot;}}
                       :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;cljs-test-runner.main&amp;quot;&amp;#93;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This pulls down my patched version of the cognitect test-runner and my ClojureScript (loose) clone of the same library. The current cognitect test-runner doesn't report non-zero exit statuses when tests fail, my patch adds them, I'm hoping to get it merged in some form or another soon.&lt;/p&gt;&lt;p&gt;Without the exit status patch Travis won't know that your tests actually failed.&lt;/p&gt;&lt;h2 id=&quot;convenience&quot;&gt;Convenience&lt;/h2&gt;&lt;p&gt;Here's a &lt;code&gt;Makefile&lt;/code&gt; that wraps up the test commands, it makes it a little easier to call:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;Makefile&quot;&gt;.PHONY: test test-clj test-cljs

test: test-clj test-cljs

test-clj:
	clojure -Atest-clj

test-cljs:
	clojure -Atest-cljs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is obviously optional, feel free to avoid it if you want to.&lt;/p&gt;&lt;h2 id=&quot;travis&amp;#95;configuration&quot;&gt;Travis configuration&lt;/h2&gt;&lt;p&gt;Now we have some tools to test our code, let's configure Travis to execute them with your &lt;code&gt;.travis.yml&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;yaml&quot;&gt;sudo: true
language: java
script: make test
install:
  - curl -O https://download.clojure.org/install/linux-install-1.9.0.358.sh
  - chmod +x linux-install-1.9.0.358.sh
  - sudo ./linux-install-1.9.0.358.sh
jdk:
  - oraclejdk8
cache:
  directories:
    - $HOME/.m2
    - $HOME/.cljs
    - $HOME/.gitlibs
    - node&amp;#95;modules
    - .cpcache
    - cljs-test-runner-out
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This configuration will set up the Clojure CLI, cache all of the appropriate directories and run your test suites. Feel free to take parts of this that you find useful and ignore others.&lt;/p&gt;&lt;p&gt;You should now connect your repo to your Travis account, it will report to you whenever your tests start failing. Enjoy!&lt;/p&gt;
</description>
<pubDate>
Thu, 29 Mar 2018 00:00:00 +0100
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2018-03-09-clojure-and-clojurescript-testing-with-the-clojure-cli/
</guid>
<link>
https://oli.me.uk/2018-03-09-clojure-and-clojurescript-testing-with-the-clojure-cli/
</link>
<title>
Clojure and ClojureScript testing with the Clojure CLI
</title>
<description>
&lt;p&gt;This post is sort of an extension of a previous post, &lt;a href='https://oli.me.uk/2018-02-26-clojure-projects-from-scratch/'&gt;Clojure projects from scratch&lt;/a&gt;. That will introduce you to structuring your project around a &lt;code&gt;deps.edn&lt;/code&gt; file, here we're going to simply add a couple of dependencies that allow you to run your tests.&lt;/p&gt;&lt;p&gt;In a &lt;a href='https://leiningen.org/'&gt;Leiningen&lt;/a&gt; project, &lt;code&gt;lein test&lt;/code&gt; will execute your Clojure tests, no questions asked. In a Clojure CLI / &lt;code&gt;deps.edn&lt;/code&gt; based project we have no such command, tests have to be executed by a custom built test runner script.&lt;/p&gt;&lt;p&gt;You probably don't want to be writing and modifying a test runner namespace every time you add a test, that's why &lt;a href='https://github.com/cognitect-labs/test-runner'&gt;test-runner&lt;/a&gt; and &lt;a href='https://github.com/Olical/cljs-test-runner'&gt;cljs-test-runner&lt;/a&gt; exist. I'm the author of the latter, I hope that doesn't put you off.&lt;/p&gt;&lt;h2 id=&quot;test-runner&quot;&gt;test-runner&lt;/h2&gt;&lt;p&gt;First we'll add test-runner, the Clojure version. This will give us an equivalent to &lt;code&gt;lein test&lt;/code&gt;. Add a &lt;code&gt;test&lt;/code&gt; alias to your &lt;code&gt;aliases&lt;/code&gt; section of your &lt;code&gt;deps.edn&lt;/code&gt; file.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:deps ;; 1
 {org.clojure/clojure {:mvn/version &amp;quot;1.9.0&amp;quot;}
  org.clojure/clojurescript {:mvn/version &amp;quot;1.10.145&amp;quot;}}

 :aliases
 {:test ;; 2
  {:extra-paths &amp;#91;&amp;quot;test&amp;quot;&amp;#93; ;; 3
   :extra-deps
   {com.cognitect/test-runner {:git/url &amp;quot;git@github.com:cognitect-labs/test-runner&amp;quot;
                               :sha &amp;quot;76568540e7f40268ad2b646110f237a60295fa3c&amp;quot;}} ;; 4
   :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;cognitect.test-runner&amp;quot;&amp;#93;}}} ;; 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let's break this down a little, just in case you aren't super familiar with &lt;code&gt;deps.edn&lt;/code&gt; just yet.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Map of your dependencies, here we're depending on the latest Clojure and ClojureScript. Having your language as a versioned dependency is a wonderful thing.&lt;/li&gt;&lt;li&gt;Our test alias, we'll activate it with &lt;code&gt;clojure -Atest&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;For Clojure tests, we need to add the test directory to the classpath.&lt;/li&gt;&lt;li&gt;Dependency on the test-runner, there may be a new commit by now. I'm waiting for my &lt;a href='https://github.com/cognitect-labs/test-runner/pull/12'&gt;return code fix&lt;/a&gt; to be merged.&lt;/li&gt;&lt;li&gt;Set the entry namespace to the test runner.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;We can now execute our tests as we would with &lt;code&gt;lein&lt;/code&gt;!&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clojure -Atest
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At the time of writing, even if your tests fail, the return code of the process will always be 0. This means that your CLI and CI will think the tests passed just fine. I've fixed this and it may have been merged by the time you're reading this. If not, feel free to use the fixed commit from my fork.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:git/url &amp;quot;git@github.com:Olical/test-runner.git&amp;quot;
 :sha &amp;quot;7c4f5bd4987ec514889c7cd7e3d13f4ef95f256b&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;cljs-test-runner&quot;&gt;cljs-test-runner&lt;/h2&gt;&lt;p&gt;Running ClojureScript tests is usually a bit of a pain. You've got to work out how to get it compiling then have that plugged into a test runner such as &lt;a href='https://github.com/bensu/doo'&gt;doo&lt;/a&gt;. This doesn't account for test file discovery, so you've still got to specify each of your test namespaces manually.&lt;/p&gt;&lt;p&gt;I've wrapped up doo with a few namespace tools and the ClojureScript compiler to give you a single command that handles all of this for you. Let's add another alias containing cljs-test-runner. You may want to check for new versions since it may have changed since I wrote this.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:test-cljs
{:extra-deps
 {olical/cljs-test-runner {:mvn/version &amp;quot;0.1.1&amp;quot;}}
 :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;cljs-test-runner.main&amp;quot;&amp;#93;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see it's extremely similar to the Clojure test-runner setup, one difference is that we don't need to add our test directory to the classpath. ClojureScript doesn't rely on the classpath, instead there is a flag that you can set if your tests are somewhere other than the default test directory.&lt;/p&gt;&lt;p&gt;You can execute your tests with the following command, it'll run them in node by default. You can change the environment to phantom if required, this may have changed since writing.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clojure -Atest-cljs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If everything went according to plan it should have found your &lt;code&gt;.cljs&lt;/code&gt; and &lt;code&gt;.cljc&lt;/code&gt; test namespaces, compiled them and executed them through node. If it didn't, I'm sure you can work it out, or raise an issue if you think there's a problem.&lt;/p&gt;&lt;h2 id=&quot;running&amp;#95;both&quot;&gt;Running both&lt;/h2&gt;&lt;p&gt;You'll now be able to run your Clojure and ClojureScript tests side by side, hassle free, locally or through CI.&lt;/p&gt;&lt;p&gt;Bear in mind that the Clojure test-runner will always return a good exit status, even when the tests fail at the time of writing. Make sure my fix has been merged or use my fork if you need the correct exit status.&lt;/p&gt;
</description>
<pubDate>
Fri, 09 Mar 2018 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2018-03-04-clojure-and-clojurescript-nrepl-with-clojure-cli/
</guid>
<link>
https://oli.me.uk/2018-03-04-clojure-and-clojurescript-nrepl-with-clojure-cli/
</link>
<title>
Clojure and ClojureScript nREPL with Clojure CLI
</title>
<description>
&lt;p&gt;If you've decided to try out the new Clojure CLI introduced with Clojure 1.9 you may have found yourself slightly lost when it comes to getting your CIDER (or other development environment) hooked up to your project through nREPL. My previous post, &lt;a href='https://oli.me.uk/2018-02-26-clojure-projects-from-scratch/'&gt;Clojure projects from scratch&lt;/a&gt;, may help you with understanding these concepts and tools if you're struggling to get going.&lt;/p&gt;&lt;p&gt;In this post I'm going to show you a few simple steps you need to take to get your nREPL running smoothly. I am hosting the ClojureScript nREPL through NodeJS, you can probably adjust the configuration if you need it to run in something else.&lt;/p&gt;&lt;h2 id=&quot;the&amp;#95;deps&quot;&gt;The deps&lt;/h2&gt;&lt;p&gt;We're going to be using the following tools:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://github.com/clojure/tools.nrepl'&gt;clojure/tools.nrepl&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/clojure-emacs/cider-nrepl'&gt;clojure-emacs/cider-nrepl&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/cemerick/piggieback'&gt;cemerick/piggieback&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Here's the &lt;code&gt;deps.edn&lt;/code&gt; file we're going to want. This is the minimal required amount, so you'll need to integrate all of this into your own &lt;code&gt;deps.edn&lt;/code&gt;. The Clojure and ClojreScript versions may vary.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:deps
 {org.clojure/clojure {:mvn/version &amp;quot;1.9.0&amp;quot;}
  org.clojure/clojurescript {:mvn/version &amp;quot;1.10.64&amp;quot;}}

 :aliases
 {:nrepl-server
  {:extra-paths &amp;#91;&amp;quot;dev&amp;quot;&amp;#93;
   :extra-deps
   {com.cemerick/piggieback {:mvn/version &amp;quot;0.2.2&amp;quot;}
    org.clojure/tools.nrepl {:mvn/version &amp;quot;0.2.12&amp;quot;}
    cider/cider-nrepl {:mvn/version &amp;quot;0.17.0-SNAPSHOT&amp;quot;}}
   :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;nrepl-server&amp;quot;&amp;#93;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You may want to add a small Makefile to make executing with this alias a little smoother:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;Makefile&quot;&gt;.PHONY: nrepl-server

nrepl-server:
	clj -Anrepl-server
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;the&amp;#95;namespaces&quot;&gt;The namespaces&lt;/h2&gt;&lt;p&gt;You may have noticed my reference to the &lt;code&gt;nrepl-server&lt;/code&gt; namespace and &lt;code&gt;dev&lt;/code&gt; directory in the &lt;code&gt;deps.edn&lt;/code&gt; file, we need to create these before our nREPL server will work.&lt;/p&gt;&lt;p&gt;Add the following files to your project:&lt;/p&gt;&lt;h3 id=&quot;dev/nrepl&amp;#95;server.clj&quot;&gt;dev/nrepl&amp;#95;server.clj&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns nrepl-server
  &amp;#40;:require &amp;#91;cider-nrepl.main :as nrepl&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn -main &amp;#91;&amp;#93;
  &amp;#40;nrepl/init &amp;#91;&amp;quot;cider.nrepl/cider-middleware&amp;quot;
               &amp;quot;cemerick.piggieback/wrap-cljs-repl&amp;quot;&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;dev/user.clj&quot;&gt;dev/user.clj&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns user
  &amp;#40;:require &amp;#91;cemerick.piggieback :as piggieback&amp;#93;
            &amp;#91;cljs.repl.node :as node-repl&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn cljs-repl &amp;#91;&amp;#93;
  &amp;#40;piggieback/cljs-repl &amp;#40;node-repl/repl-env&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These files will allow us to firstly boot our nREPL server with the correct middleware and secondly allow us to easily drop into a ClojureScript REPL.&lt;/p&gt;&lt;h2 id=&quot;getting&amp;#95;connected&quot;&gt;Getting connected&lt;/h2&gt;&lt;p&gt;If you added a rule to your &lt;code&gt;Makefile&lt;/code&gt;, you can use &lt;code&gt;make nrepl-server&lt;/code&gt;, alternatively just type &lt;code&gt;clj -Anrepl-server&lt;/code&gt;. You should see something like this:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ make nrepl-server
clj -Anrepl-server
nREPL server started on port 40047 on host localhost - nrepl://localhost:40047
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Your bindings may vary, but in &lt;a href='http://spacemacs.org/'&gt;Spacemacs&lt;/a&gt; I would type &lt;code&gt;,sc&lt;/code&gt; and then just hit enter twice to select &lt;code&gt;localhost&lt;/code&gt; and the currently running server. CIDER knows the server port because it should've created a &lt;code&gt;.nrepl-port&lt;/code&gt; file in your current directory.&lt;/p&gt;&lt;p&gt;Once you're connected, you can start evaluating Clojure code, how wonderful! When you wish to drop into a ClojureScript REPL backed by NodeJS (by default), you can use the &lt;code&gt;cljs-repl&lt;/code&gt; function we defined in your &lt;code&gt;user&lt;/code&gt; namespace. Just open the REPL (&lt;code&gt;,ss&lt;/code&gt; in Spacemacs) and execute &lt;code&gt;&amp;#40;cljs-repl&amp;#41;&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;If everything went according to plan, you should now be able to evaluate ClojureScript code as easy as Clojure. If you are jumping between Clojure and ClojureScript namespaces, you'll have to connect twice with one of those REPLs in ClojureScript mode.&lt;/p&gt;&lt;p&gt;A REPL can only ever be serving Clojure or ClojureScript, not both at the same time. Once you execute &lt;code&gt;&amp;#40;cljs-repl&amp;#41;&lt;/code&gt; that connection becomes ClojureScript specific.&lt;/p&gt;
</description>
<pubDate>
Sun, 04 Mar 2018 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2018-02-26-clojure-projects-from-scratch/
</guid>
<link>
https://oli.me.uk/2018-02-26-clojure-projects-from-scratch/
</link>
<title>
Clojure projects from scratch
</title>
<description>
&lt;p&gt;This post is intended &lt;i&gt;primarily&lt;/i&gt; for two groups of people:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;People just starting out in Clojure, who know parts of the language but don't know how to begin structuring a real project.&lt;/li&gt;&lt;li&gt;Seasoned Clojurians who wish to see how to structure a project with the new Clojure CLI + &lt;code&gt;deps.edn&lt;/code&gt; and not &lt;a href='https://leiningen.org/'&gt;lein&lt;/a&gt; or &lt;a href='http://boot-clj.com/'&gt;boot&lt;/a&gt; (even though they're still awesome).&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;My goal is to teach you how to go from an empty directory, to a project you can run, test, compile and (if you wish to) publish with ease. We're going to get there through a series of relatively small steps so you can understand all the tools you're using.&lt;/p&gt;&lt;p&gt;There won't be an awful lot of Clojure code here, so don't worry if you're still getting your head around the language itself. The only code example will be a &quot;Hello, World!&quot;, if that helps.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; Note: This post assumes usage of Linux, OSX or similar, I'm afraid it isn't intended for Windows users since I just don't have the knowledge to help you there. Some of the information will apply, but you'll have to adapt things, I'm sure you can find Windows specific guides for the parts that don't fit. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;I'm not going into what editor you should use because that's a book in itself. If you're totally at a loss, check out &lt;a href='https://cursive-ide.com/'&gt;Cursive&lt;/a&gt;, although I use &lt;a href='http://spacemacs.org/'&gt;Spacemacs&lt;/a&gt; because I can't survive without good Vim emulation. There's probably a great plugin for your editor of choice and instructions on getting started, have a Google.&lt;/p&gt;&lt;p&gt;A lot of what I'm going to be talking about can be found in practice in &lt;a href='https://github.com/robert-stuttaford/bridge'&gt;github.com/robert-stuttaford/bridge&lt;/a&gt;, you may want to have a peruse at some point.&lt;/p&gt;&lt;h2 id=&quot;installing&amp;#95;the&amp;#95;clojure&amp;#95;cli&quot;&gt;Installing the Clojure CLI&lt;/h2&gt;&lt;p&gt;To run Clojure you'll need the command line tool (introduced around the time of Clojure 1.9) that manages dependencies and allows you execute code.&lt;/p&gt;&lt;p&gt;If you're on OSX, you can use &lt;code&gt;brew&lt;/code&gt; to install the CLI.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ brew install clojure
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I have found that I could install it through the Arch Linux package manager although it was slightly out of date at the time of writing, so I don't recommend this just yet. If you're on Linux you can run the manual installer easily enough.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ curl -O https://download.clojure.org/install/linux-install-1.9.0.326.sh
$ sudo bash linux-install-1.9.0.326.sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To update, use the package manager you used for the installation or find the latest Linux installer URL on the &lt;a href='https://clojure.org/guides/getting_started'&gt;getting started&lt;/a&gt; page.&lt;/p&gt;&lt;p&gt;You should now be able to drop into a Clojure REPL with one command. You can run &lt;code&gt;clojure&lt;/code&gt; or &lt;code&gt;clj&lt;/code&gt; in your terminal, the latter has a slightly better editing experience but requires you to have &lt;code&gt;rlwrap&lt;/code&gt; installed.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj
Clojure 1.9.0
user=&amp;gt; &amp;#40;+ 10 15&amp;#41;
25
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;initial&amp;#95;files&quot;&gt;Initial files&lt;/h2&gt;&lt;p&gt;Presuming our project is called &lt;code&gt;hey&lt;/code&gt;, let's go ahead and create these directories and files:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ mkdir -p hey/{src/hey,test/hey}
$ cd hey
$ touch src/hey/core.clj test/hey/core&amp;#95;test.clj
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This provides us with the following directory structure:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ tree
.
├── src
│   └── hey
│       └── core.clj
└── test
    └── hey
        └── core&amp;#95;test.clj

4 directories, 2 files
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let's insert some content into these files:&lt;/p&gt;&lt;h3 id=&quot;src/hey/core.clj&quot;&gt;src/hey/core.clj&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns hey.core&amp;#41;

&amp;#40;defn -main &amp;#91;&amp;#93;
  &amp;#40;println &amp;quot;Hello, World!&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;test/hey/core&amp;#95;test.clj&quot;&gt;test/hey/core&amp;#95;test.clj&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns hey.core-test
  &amp;#40;:require &amp;#91;clojure.test :as t&amp;#93;
            &amp;#91;hey.core :as sut&amp;#93;&amp;#41;&amp;#41;

&amp;#40;t/deftest basic-tests
  &amp;#40;t/testing &amp;quot;it says hello to everyone&amp;quot;
    &amp;#40;t/is &amp;#40;= &amp;#40;with-out-str &amp;#40;sut/-main&amp;#41;&amp;#41; &amp;quot;Hello, World!\n&amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The main namespace simply prints &quot;Hello, World!&quot; when executed and the test confirms that functionality.&lt;/p&gt;&lt;h2 id=&quot;running&amp;#95;your&amp;#95;code&quot;&gt;Running your code&lt;/h2&gt;&lt;p&gt;Now that we have a bare bones program and test file in our project directory, we're probably going to want to run it. We can do that with the Clojure CLI, go ahead and execute the following:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj -m hey.core
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You should see &quot;Hello, World!&quot; printed in your terminal. Let's try jumping into a REPL so we can interact with our code directly:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj
Clojure 1.9.0
user=&amp;gt; &amp;#40;load &amp;quot;hey/core&amp;quot;&amp;#41;
nil
user=&amp;gt; &amp;#40;in-ns 'hey.core&amp;#41;
#object&amp;#91;clojure.lang.Namespace 0x2072acb2 &amp;quot;hey.core&amp;quot;&amp;#93;
hey.core=&amp;gt; &amp;#40;-main&amp;#41;
Hello, World!
nil
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If your editor supports Clojure, you can probably connect a REPL and interact with your code through there too. With spacemacs I would type &lt;code&gt;,'&lt;/code&gt; to &quot;jack in&quot; with CIDER. I can then use &lt;code&gt;,ee&lt;/code&gt; to evaluate expressions as I work.&lt;/p&gt;&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;&lt;p&gt;We have a test file but no way to run it. We could create our own test runner namespace that executed &lt;code&gt;clojure.test/run-all-tests&lt;/code&gt;, but that requires telling it about every testing namespace we have in our project. It gets tedious after a while, so let's get something that does it for us.&lt;/p&gt;&lt;p&gt;Create a file called &lt;code&gt;deps.edn&lt;/code&gt; at the top of your project and add the following to it:&lt;/p&gt;&lt;h3 id=&quot;deps.edn&quot;&gt;deps.edn&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:deps
 {org.clojure/clojure {:mvn/version &amp;quot;1.9.0&amp;quot;}}

 :aliases
 {:test
  {:extra-paths &amp;#91;&amp;quot;test&amp;quot;&amp;#93;
   :extra-deps
   {com.cognitect/test-runner {:git/url &amp;quot;git@github.com:cognitect-labs/test-runner&amp;quot;
                               :sha &amp;quot;5f2b5c2efb444df76fb5252102b33f542ebf7f58&amp;quot;}}
   :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;cognitect.test-runner&amp;quot;&amp;#93;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let's break this down:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;:deps&lt;/code&gt; is where we specify our dependencies, right now all we're depending on is Clojure 1.9.0.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:aliases&lt;/code&gt; is where we specify special overrides that we can apply with the &lt;code&gt;-A&lt;/code&gt; argument to the CLI.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:test&lt;/code&gt; is the name of our alias, it adds the &lt;code&gt;test&lt;/code&gt; directory to the paths list and &lt;code&gt;com.cognitect/test-runner&lt;/code&gt; to the dependencies.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:main-opts&lt;/code&gt; instructs Clojure that we want these arguments applied when the alias is active. In this case, we're using &lt;code&gt;-m&lt;/code&gt; to specify which namespace to execute.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The usage of &lt;code&gt;deps.edn&lt;/code&gt; is documented further in &lt;a href='https://clojure.org/guides/deps_and_cli'&gt;the deps guide&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;This will discover and run our test for us, let's run it now:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj -Atest

Running tests in #{&amp;quot;test&amp;quot;}

Testing hey.core-test

Ran 1 tests containing 1 assertions.
0 failures, 0 errors.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Hopefully you see the same success message as myself. You can see that we applied the values specified in our alias with the &lt;code&gt;-Atest&lt;/code&gt; argument.&lt;/p&gt;&lt;h2 id=&quot;building&amp;#95;executable&amp;#95;jars&quot;&gt;Building executable jars&lt;/h2&gt;&lt;p&gt;In this section we're going to build an &quot;uberjar&quot; containing your application alongside all of the dependencies it requires to run.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; You only need to bother with uberjars if you're writing an application you wish to deploy and run somewhere. If you're building a library for others to depend on you probably won't need this. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Compiling your project into an uberjar will involve similar steps to getting your tests running, we're going to add another alias with another dependency which does the job for us.&lt;/p&gt;&lt;p&gt;Go ahead and add this new alias to the &lt;code&gt;:aliases&lt;/code&gt; section of your &lt;code&gt;deps.edn&lt;/code&gt; file, next to the &lt;code&gt;:test&lt;/code&gt; alias:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:uberjar
{:extra-deps
 {pack/pack.alpha
  {:git/url &amp;quot;git@github.com:juxt/pack.alpha.git&amp;quot;
   :sha     &amp;quot;e6d0691c5f58135e1ef6fb1c9dda563611d36205&amp;quot;}}
 :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;mach.pack.alpha.capsule&amp;quot; &amp;quot;deps.edn&amp;quot; &amp;quot;dist/hey.jar&amp;quot;&amp;#93;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now build a jar that we can execute directly through the &lt;code&gt;java&lt;/code&gt; program, without the Clojure CLI:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj -Auberjar
$ java -jar dist/hey.jar # Drops us into a Clojure REPL.
$ java -jar dist/hey.jar -m hey.core # Executes our &amp;quot;Hello, World!&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Please note that your code has not been AOT (ahead of time) compiled, it's still just plain Clojure that's compiled as and when it's required at run time. This can mean very slightly slower startup times when you're working with a large codebase.&lt;/p&gt;&lt;p&gt;If this becomes an issue for you you'll have to work out how to perform AOT compilation as you build your uberjar. By then, pack may even support it as a core feature.&lt;/p&gt;&lt;h2 id=&quot;publishing&amp;#95;to&amp;#95;clojars&quot;&gt;Publishing to Clojars&lt;/h2&gt;&lt;p&gt;In this section we're going to publish a small jar file to &lt;a href='https://clojars.org/'&gt;Clojars&lt;/a&gt; containing only your source code, we'll be using maven to perform the deploy.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; This is intended for libraries that others will depend on and use, you won't need to worry about this section if you're building an application you'll be running. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;First, we're going to add your Clojars login to &lt;code&gt;&amp;#126;/.m2/settings.xml&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;settings&amp;gt;
  &amp;lt;servers&amp;gt;
    &amp;lt;server&amp;gt;
      &amp;lt;id&amp;gt;clojars&amp;lt;/id&amp;gt;
      &amp;lt;username&amp;gt;username&amp;lt;/username&amp;gt;
      &amp;lt;password&amp;gt;password&amp;lt;/password&amp;gt;
    &amp;lt;/server&amp;gt;
  &amp;lt;/servers&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we're going to generate your base &lt;code&gt;pom.xml&lt;/code&gt; file, you should run this command whenever you're going to publish so the dependencies get updated:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj -Spom
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here's my example version, I've annotated each section. There's some you'll want to change as well as a couple of parts you'll want to add and update:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

  &amp;lt;!-- Here by default, but will need updating --&amp;gt;
  &amp;lt;groupId&amp;gt;org.clojars.olical&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;hey&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.1.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;name&amp;gt;hey&amp;lt;/name&amp;gt;

  &amp;lt;!-- Here by default, updated by `clj -Spom` --&amp;gt;
  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.clojure&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;clojure&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.9.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;
  &amp;lt;build&amp;gt;
    &amp;lt;sourceDirectory&amp;gt;src&amp;lt;/sourceDirectory&amp;gt;

    &amp;lt;!-- Essential for bundling your source files into the JAR --&amp;gt;
    &amp;lt;resources&amp;gt;
      &amp;lt;resource&amp;gt;
        &amp;lt;directory&amp;gt;src&amp;lt;/directory&amp;gt;
      &amp;lt;/resource&amp;gt;
    &amp;lt;/resources&amp;gt;
  &amp;lt;/build&amp;gt;
  &amp;lt;repositories&amp;gt;
    &amp;lt;repository&amp;gt;
      &amp;lt;id&amp;gt;clojars&amp;lt;/id&amp;gt;
      &amp;lt;url&amp;gt;https://clojars.org/repo&amp;lt;/url&amp;gt;
    &amp;lt;/repository&amp;gt;
  &amp;lt;/repositories&amp;gt;

  &amp;lt;!-- Essential for pushing to Clojars --&amp;gt;
  &amp;lt;distributionManagement&amp;gt;
    &amp;lt;repository&amp;gt;
      &amp;lt;id&amp;gt;clojars&amp;lt;/id&amp;gt;
      &amp;lt;name&amp;gt;Clojars repository&amp;lt;/name&amp;gt;
      &amp;lt;url&amp;gt;https://clojars.org/repo&amp;lt;/url&amp;gt;
    &amp;lt;/repository&amp;gt;
  &amp;lt;/distributionManagement&amp;gt;

  &amp;lt;!-- Optional extras for Clojars --&amp;gt;
  &amp;lt;description&amp;gt;Just a Hello, World!&amp;lt;/description&amp;gt;
  &amp;lt;url&amp;gt;https://github.com/Olical/clojure-hey-example&amp;lt;/url&amp;gt;
  &amp;lt;licenses&amp;gt;
    &amp;lt;license&amp;gt;
      &amp;lt;name&amp;gt;Unlicense&amp;lt;/name&amp;gt;
      &amp;lt;url&amp;gt;https://unlicense.org/&amp;lt;/url&amp;gt;
    &amp;lt;/license&amp;gt;
  &amp;lt;/licenses&amp;gt;
  &amp;lt;scm&amp;gt;
    &amp;lt;url&amp;gt;https://github.com/Olical/clojure-hey-example&amp;lt;/url&amp;gt;
  &amp;lt;/scm&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now tell maven to build and deploy a jar to Clojars:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ mvn deploy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A lot of this information comes from &lt;a href='https://github.com/clojars/clojars-web/wiki/Pushing'&gt;Clojar's guide to pushing&lt;/a&gt; and &lt;a href='https://maven.apache.org/guides/mini/guide-3rd-party-jars-remote.html'&gt;Maven's guide to deploying 3rd party jars&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;If everything went to plan, your Clojars account should now contain a fresh new jar. Note that this is &lt;i&gt;not&lt;/i&gt; an uberjar, it only contains your source files and dependency information, not the actual dependencies themselves. The dependencies will be resolved by a tool such as the Clojure CLI.&lt;/p&gt;&lt;h2 id=&quot;ergonomics&quot;&gt;Ergonomics&lt;/h2&gt;&lt;p&gt;As it stands, to deploy our jar to Clojars we'll want to take the following steps:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Update the version number in our &lt;code&gt;pom.xml&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;Run the tests with &lt;code&gt;clj -Atest&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;Run &lt;code&gt;clj -Spom&lt;/code&gt; to update our &lt;code&gt;pom.xml&lt;/code&gt; with any dependency changes.&lt;/li&gt;&lt;li&gt;Run &lt;code&gt;mvn deploy&lt;/code&gt;. &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This isn't particularly catchy, so we'll wrap everything we've seen so far in a pretty little &lt;code&gt;Makefile&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;makefile&quot;&gt;.PHONY: run test uberjar deploy

run:
	clj -m hey.core

test:
	clj -Atest

uberjar:
	clj -Auberjar

deploy: test
	clj -Spom
	mvn deploy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now all you need to do when you wish to deploy is bump the version number in your &lt;code&gt;pom.xml&lt;/code&gt; and execute &lt;code&gt;make deploy&lt;/code&gt;.&lt;/p&gt;&lt;h2 id=&quot;thanks!&quot;&gt;Thanks!&lt;/h2&gt;&lt;p&gt;I really hope this post has helped you out! You can find the example project I built during the writing of this post at &lt;a href='https://github.com/Olical/clojure-hey-example'&gt;github.com/Olical/clojure-hey-example&lt;/a&gt; and the &lt;a href='https://clojars.org/org.clojars.olical/hey/versions/2.1.0-SNAPSHOT'&gt;Clojars page here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Happy Clojuring!&lt;/p&gt;
</description>
<pubDate>
Mon, 26 Feb 2018 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2017-10-27-hello-world/
</guid>
<link>
https://oli.me.uk/2017-10-27-hello-world/
</link>
<title>
Hello, World!
</title>
<description>
&lt;p&gt;I've, once again, migrated my blog onto another platform. This time I've gone from WordPress on my own Linode to &lt;a href=&quot;&quot;&gt;Cryogen&lt;/a&gt; on GitHub pages. This means a few things:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;I no longer need to worry about running my own server, even though Linode is fantastic. I just don't want to maintain anything, especially WordPress.&lt;/li&gt;&lt;li&gt;I can blog with a Clojure based platform and integrate &lt;a href=&quot;&quot;&gt;Klipse&lt;/a&gt; easily for interactive lispy posts.&lt;/li&gt;&lt;li&gt;I can write my posts in markdown with Emacs and keep it all on &lt;a href=&quot;https://github.com/Olical/olical.github.io&quot;&gt;GitHub&lt;/a&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;the_migration&quot;&gt;The migration&lt;/h2&gt; &lt;p&gt;I wanted to start fresh since my old blog is full of so many topics that I do not feel reflect my true interests anymore, so here I am with a blank slate. Luckily I found a way to keep my WordPress site exactly how it was so as not to break a single URL without running WordPress itself.&lt;/p&gt;&lt;p&gt;I used &lt;a href=&quot;https://en-gb.wordpress.org/plugins/simply-static/&quot;&gt;Simply Static&lt;/a&gt; to generate a snapshot of my entire blog which I could then merge into my GitHub pages repositories top level. This means every URL that used to work with my original blog will work with this one.&lt;/p&gt;&lt;p&gt;I don't promote my old posts through this anymore, but they're still there, I even preserved &lt;a href=&quot;https://oli.me.uk/wp-index.html&quot;&gt;the original homepage&lt;/a&gt;.&lt;/p&gt;&lt;h2 id=&quot;the_payoff&quot;&gt;The payoff&lt;/h2&gt;&lt;p&gt;I think it was worth it since I no longer have to run a server and I can do things like this.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-scheme nohighlight&quot;&gt;(define (add a b)
  (if (= b 0)
    a
    (add (+ a 1) (- b 1))))
    
(add 10 20)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I also did this entire migration today while on trains and in cars over mobile internet, which was fun.&lt;/p&gt;
</description>
<pubDate>
Fri, 27 Oct 2017 00:00:00 +0100
</pubDate>
</item>
</channel>
</rss>
