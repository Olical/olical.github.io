<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='https://oli.me.uk/' rel='self' type='application/rss+xml'/>
<title>
(ollie {:on :parens})
</title>
<link>
https://oli.me.uk/
</link>
<description>
On languages and text editors.
</description>
<lastBuildDate>
Thu, 18 Jul 2019 14:06:01 +0100
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
https://oli.me.uk/2019-07-16-exploring-repl-tooling-with-prepl/
</guid>
<link>
https://oli.me.uk/2019-07-16-exploring-repl-tooling-with-prepl/
</link>
<title>
Exploring REPL tooling with socket prepl
</title>
<description>
&lt;blockquote&gt;&lt;p&gt; This post is mainly to help me plan my talk at &lt;a href='https://www.meetup.com/London-Clojurians/events/262000841/'&gt;London Clojurians&lt;/a&gt; on 16th July 2019 on the same topic. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;If you're reading this, you're &lt;i&gt;probably&lt;/i&gt; a &lt;a href='https://clojure.org/'&gt;Clojure&lt;/a&gt; programmer to some degree, even if that's just dipping your toes into the pool of immutability now and again. Chances are you've encountered some sort of command line tooling such as &lt;a href='https://leiningen.org/'&gt;Leiningen&lt;/a&gt; or the &lt;a href='https://clojure.org/guides/deps_and_cli'&gt;Clojure CLI&lt;/a&gt; as well as some sort of REPL tooling for your editor.&lt;/p&gt;&lt;p&gt;This post is (hopefully) going to explain the inner workings of your current REPL tooling, as well as explain how my preferred tooling works and how it's different.&lt;/p&gt;&lt;h2 id=&quot;what&amp;#95;is&amp;#95;repl&amp;#95;tooling?&quot;&gt;What is REPL tooling?&lt;/h2&gt;&lt;p&gt;For those of you that aren't sure, you probably already use it already, here's an incomplete list of tools to give you an idea.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://cider.mx/'&gt;CIDER&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/BetterThanTomorrow/calva'&gt;Calva&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/tpope/vim-fireplace'&gt;vim-fireplace&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/liquidz/vim-iced'&gt;vim-iced&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/Olical/conjure'&gt;Conjure&lt;/a&gt; (this one's mine but we'll get to that)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;There's essentially one or more tools for every editor in existence out there somewhere. REPL tooling, to me, means a plugin that connects to some remote Clojure (or &lt;a href='https://clojurescript.org/'&gt;ClojureScript&lt;/a&gt;) process and allows you to send code to that process for evaluation from your text editor of choice.&lt;/p&gt;&lt;p&gt;It's much richer than a normal terminal REPL since you can use mappings to send specific forms inside your editor to the REPL and get the results beside the source code. They can provide autocomplete, documentation lookup, go to definition, formatting and much more without any static analysis or extra programs. The tooling gets to be your IDE by running inside your existing Clojure process!&lt;/p&gt;&lt;p&gt;This is a super power very few languages get to enjoy, it's something that's hard to understand as a beginner. It's something that, when it clicks, can't easily be left behind. REPL tooling is how we write our Clojure programs, it's the single essential tool in any Clojure programmer's toolbelt. Without this kind of tooling your only way to try something new is to turn it off and on again, which is completely normal across the industry. Normal isn't always good.&lt;/p&gt;&lt;p&gt;These plugins do not exist in a vacuum, they're built upon a shared interface for connecting to REPLs over a network. These interfaces influence the design of the plugins, their methodologies morph to fit the foundation they're built on. Let's explore what your REPL tooling uses to actually make things happen.&lt;/p&gt;&lt;h2 id=&quot;nrepl&quot;&gt;nREPL&lt;/h2&gt;&lt;p&gt;&lt;a href='https://nrepl.org/'&gt;nREPL&lt;/a&gt; is the golden standard of networked REPLs, it always has been and probably always will be. &lt;a href='https://batsov.com/'&gt;Bozhidar&lt;/a&gt; has done a great job of building up a community around the CIDER and nREPL stack. Although originally tailored for the Emacs crowd, nREPL and some of CIDER's middleware (we'll get to what that is soon) has been extracted in such a way that any other editor tooling can lean on this solid foundation.&lt;/p&gt;&lt;p&gt;I used fireplace in Vim for years which connected to the same server as my colleague in Emacs, they get to use the same community effort to share that power. The editor plugins are then thin clients around this nREPL based stack, the majority of the clever Clojure workings occur within the nREPL server which sits inside our project's process.&lt;/p&gt;&lt;p&gt;To extend nREPL we have to write &lt;a href='https://nrepl.org/nrepl/design/middleware.html'&gt;middleware&lt;/a&gt; for our nREPL server, this can add new operations and capabilities although it requires writing an nREPL specific wrapper to hook it all together. Just like Leiningen plugins, you can rely on a generic library but you need to write something nREPL specific to connect it up in such a way that editors can use it.&lt;/p&gt;&lt;p&gt;Let's start an nREPL server and see how it behaves when we connect to it via &lt;code&gt;telnet&lt;/code&gt; (I'm going to use the &lt;a href='https://clojure.org/guides/deps_and_cli'&gt;Clojure CLI&lt;/a&gt; for this). Feel free to follow along in your terminal!&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;clj -Sdeps '{:deps {nrepl/nrepl {:mvn/version &amp;quot;0.7.0-alpha1&amp;quot;}}}' -m nrepl.cmdline -t nrepl.transport/edn
nREPL server started on port 35177 on host localhost - nrepl+edn://localhost:35177
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We have to depend on &lt;code&gt;nrepl/nrepl&lt;/code&gt;, enter the &lt;code&gt;nrepl.cmdline&lt;/code&gt; namespace and then specify that we want to use &lt;a href='https://github.com/edn-format/edn'&gt;EDN&lt;/a&gt;. It defaults to &lt;a href='https://en.wikipedia.org/wiki/Bencode'&gt;Bencode&lt;/a&gt; which is a binary representation that's not usable from the CLI. EDN support isn't in a stable release at the time of writing, so we need to rely on &lt;code&gt;0.7.0-alpha1&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;So it's chosen a port for us, &lt;code&gt;35177&lt;/code&gt; in this case (yours will probably be different!), let's &lt;code&gt;telnet&lt;/code&gt; into that and try evaluating something.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;telnet 127.0.0.1 35177
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '&amp;#94;&amp;#93;'.
&amp;#40;+ 10 10&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And in our nREPL server we see the following with a stack trace.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ERROR: Unhandled REPL handler exception processing message &amp;#40;+ 10 10&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That's because nREPL expects all messages to be wrapped in a map data structure with an &lt;a href='https://github.com/clojure/tools.nrepl/blob/master/doc/ops.md'&gt;&lt;code&gt;op&lt;/code&gt;&lt;/a&gt; key that we can set to &lt;code&gt;:eval&lt;/code&gt; to perform an evaluation. Middleware adds more &lt;code&gt;op&lt;/code&gt;s to your server. Let's send this over &lt;code&gt;telnet&lt;/code&gt; instead with a new &quot;session&quot;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;telnet 127.0.0.1 35177
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '&amp;#94;&amp;#93;'
-&amp;gt; {:op :clone}
&amp;lt;- {:session &amp;quot;621d5eda-799c-4447-b3e9-4a358eeee821&amp;quot;, :new-session &amp;quot;8ece86b4-79d8-4753-a5f2-d0246d86fe83&amp;quot;, :status #{:done}}
-&amp;gt; {:op :eval, :code &amp;quot;&amp;#40;+ 10 10&amp;#41;&amp;quot;, :session &amp;quot;8ece86b4-79d8-4753-a5f2-d0246d86fe83&amp;quot;}
&amp;lt;- {:session &amp;quot;8ece86b4-79d8-4753-a5f2-d0246d86fe83&amp;quot;, :ns &amp;quot;user&amp;quot;, :value &amp;quot;20&amp;quot;}
&amp;lt;- {:session &amp;quot;8ece86b4-79d8-4753-a5f2-d0246d86fe83&amp;quot;, :status #{:done}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I've added arrows to illustrate where I was sending (&lt;code&gt;-&amp;gt;&lt;/code&gt;) and where nREPL was responding (&lt;code&gt;&amp;lt;-&lt;/code&gt;), as you can see, it's a little back and forth. We have to clone the root session, grab that new ID, send an &lt;code&gt;:eval&lt;/code&gt; with our code and the session ID then get back two responses.&lt;/p&gt;&lt;p&gt;The first contains the value, the second tells us the session is &lt;code&gt;:done&lt;/code&gt;, I'm not really sure what that means. I &lt;i&gt;think&lt;/i&gt; it means whatever we evaluated is done and there will be no further output.&lt;/p&gt;&lt;p&gt;So, your nREPL tooling essentially connects for you, manages your sessions and dishes out various &lt;code&gt;op&lt;/code&gt;s for you as you work. I think things like autocompletion are actually an &lt;code&gt;op&lt;/code&gt;, for example. This does mean that nREPL has a bunch of plumbing that you need to be aware of while building tools (sessions etc) but for good reasons, it'll allow you to cancel long running or infinite evaluations, for example.&lt;/p&gt;&lt;p&gt;There's not really much else to show with regards to nREPL, I think &lt;a href='https://juxt.pro/blog/posts/nrepl.html'&gt;JUXT's post on nREPL&lt;/a&gt; is a fantastic resource if you wish to know more. We're going to move onto an equivalent technology that's built into newer Clojure (and ClojureScript!) versions, let's compare the value and trade offs.&lt;/p&gt;&lt;h2 id=&quot;socket&amp;#95;repl&quot;&gt;Socket REPL&lt;/h2&gt;&lt;p&gt;So you may have seen the term thrown about in various Clojure circles but not many people are using it &quot;in anger&quot; right now. The socket REPL is exactly what the name implies, a REPL attached to a socket. Let's start a server now, you can do it from the CLI.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;clj -J-Dclojure.server.jvm=&amp;quot;{:port 5555 :accept clojure.core.server/repl}&amp;quot;
Clojure 1.10.1
user=&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So we don't need any dependencies (other than Clojure &lt;code&gt;1.10.0&lt;/code&gt;+) and we get dropped into a regular REPL after it starts. Let's &lt;code&gt;telnet&lt;/code&gt; into port &lt;code&gt;5555&lt;/code&gt; (which I've selected) and send it some code!&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;telnet 127.0.0.1 5555
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '&amp;#94;&amp;#93;'.
user=&amp;gt; &amp;#40;+ 10 10&amp;#41;
20
user=&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What's interesting here is that we have the &lt;code&gt;user=&amp;gt;&lt;/code&gt; prefix, just like the original REPL in the first terminal. It's exactly the same as if we typed that code into the normal default REPL, but we can do it over the network. What happens when we print something though.&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;user=&amp;gt; &amp;#40;println &amp;quot;Hello, World!&amp;quot;&amp;#41;
Hello, World!
nil
user=&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;Ah, herein lies a problem. Although we as humans can pretty easily tell that the first line is from stdout and the second is the &lt;code&gt;nil&lt;/code&gt; returned from calling &lt;code&gt;println&lt;/code&gt;, programs can't. Writing some software to understand what's an error, stdout, stderr or a successful evaluation result with this tool would be a nightmare.&lt;/p&gt;&lt;p&gt;What we really need is a REPL over the network that evaluates code for us and wraps the responses in some sort of data structure so we knew what kind of response it was.&lt;/p&gt;&lt;h2 id=&quot;enter&amp;#95;the&amp;#95;prepl&quot;&gt;Enter the prepl&lt;/h2&gt;&lt;p&gt;Say hello to your new best friend, the prepl (pronounced like &quot;prep-ul&quot;, not &quot;p-repl&quot;), it does just what we described! Let's start up a prepl and give our previous &lt;code&gt;println&lt;/code&gt; evaluation another go.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;clj -J-Dclojure.server.jvm=&amp;quot;{:port 5555 :accept clojure.core.server/io-prepl}&amp;quot;
Clojure 1.10.1
user=&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Starting a prepl is done by starting a normal socket REPL but you give it a different &lt;code&gt;:accept&lt;/code&gt; function, this handles all input and output for the socket. You can learn a little more about starting prepls in my &lt;a href='https://oli.me.uk/2019-03-22-clojure-socket-prepl-cookbook/'&gt;Clojure socket prepl cookbook&lt;/a&gt; post.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;telnet 127.0.0.1 5555
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '&amp;#94;&amp;#93;'.
&amp;#40;println &amp;quot;Hello, World!&amp;quot;&amp;#41;
{:tag :out, :val &amp;quot;Hello, World!\n&amp;quot;}
{:tag :ret, :val &amp;quot;nil&amp;quot;, :ns &amp;quot;user&amp;quot;, :ms 121, :form &amp;quot;&amp;#40;println \&amp;quot;Hello, World!\&amp;quot;&amp;#41;&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Excellent! We connect to the same port as before, send the same code as before, but we get back two wrapped responses. We can parse these two EDN values one line at a time and dispatch some code based on the &lt;code&gt;:tag&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;This is more than enough information for some remote program to connect, evaluate and act on the responses. These are the exact principals that &lt;a href='https://github.com/Olical/conjure'&gt;Conjure&lt;/a&gt; is built on top of, it builds strings of Clojure code and fires them at a prepl for you. This means your project doesn't require any dependencies to enable your REPL tooling, you can just start a server and connect your editor to it, it'll handle the rest.&lt;/p&gt;&lt;p&gt;One of my favourite things about this is that ClojureScript support doesn't require you to jump through any hoops like &lt;a href='https://github.com/nrepl/piggieback'&gt;piggieback&lt;/a&gt; for nREPL. We can just start a ClojureScript prepl and connect to that, let's start one that automatically opens and runs in our browser.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; Yes, this is all built into vanilla ClojureScript, just make sure you're using the latest version! I've had a few patches already merged to unify the ClojureScript prepl with the canonical Clojure one, but I still have patch outstanding (&lt;a href='https://clojure.atlassian.net/browse/CLJS-3096'&gt;CLJS-3096&lt;/a&gt;). Hopefully my work here makes future prepl tooling authors lives a lot easier! &lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;clj -J-Dclojure.server.browser=&amp;quot;{:port 5555 :accept cljs.server.browser/prepl}&amp;quot;
Clojure 1.10.1
user=&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So our prepl server is up (on the same port as before) and we get dropped into a regular &lt;i&gt;Clojure&lt;/i&gt; REPL, this isn't ClojureScript. We've started a ClojureScript prepl from inside a JVM process. If you want to have figwheel building your ClojureScript as well as a prepl then check out the &lt;a href='https://oli.me.uk/2019-03-22-clojure-socket-prepl-cookbook/#figwheel-and-prepl'&gt;figwheel section&lt;/a&gt; in my prepl post. A prepl can be plugged into any ClojureScript environment, it just might take a little research.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;telnet 127.0.0.1 5555
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '&amp;#94;&amp;#93;'.
&amp;#40;println &amp;quot;Hello, World!&amp;quot;&amp;#41;
{:tag :out, :val &amp;quot;Hello, World!&amp;quot;}
{:tag :out, :val &amp;quot;\n&amp;quot;}
{:tag :ret, :val &amp;quot;nil&amp;quot;, :ns &amp;quot;cljs.user&amp;quot;, :ms 161, :form &amp;quot;&amp;#40;println \&amp;quot;Hello, World!\&amp;quot;&amp;#41;&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Well that's pretty cool but how did this work. The JVM process ended up compiling our ClojureScript to JavaScript, sent that off to a newly opened browser tab in Firefox and evaluated it there. It gathered the results and printed that out of my socket prepl with each output wrapped in machine friendly data.&lt;/p&gt;&lt;p&gt;The two &lt;code&gt;:out&lt;/code&gt; results is probably due to how &lt;code&gt;println&lt;/code&gt; is implemented in ClojureScript. If you write prepl tooling finding these sorts of differences in the two becomes quite common place.&lt;/p&gt;&lt;h2 id=&quot;how&amp;#95;conjure&amp;#95;uses&amp;#95;the&amp;#95;prepl&quot;&gt;How Conjure uses the prepl&lt;/h2&gt;&lt;p&gt;&lt;a href='https://github.com/Olical/conjure'&gt;Conjure&lt;/a&gt; is my Clojure(Script) tooling for &lt;a href='https://neovim.io/'&gt;Neovim&lt;/a&gt;, written in Clojure and running on top of prepl connections. It has it's own JVM that build strings of Clojure code to send to your prepl for evaluations.&lt;/p&gt;&lt;p&gt;It supports things like documentation lookup, go to definition and completion (via &lt;a href='https://github.com/alexander-yakushev/compliment'&gt;Compliment&lt;/a&gt; which is injected for you). None of this requires any dependencies or changes to your existing project, other than starting a prepl.&lt;/p&gt;&lt;p&gt;That prepl isn't modified in any way though, it just acts as a way to evaluate code remotely that Conjure takes advantage of. If it was built on top of nREPL I supposed I'd be relying on a few bits of middleware, I'd maybe be more inclined to require a project dependency since using nREPL requires one anyway.&lt;/p&gt;&lt;p&gt;Let's look at how Conjure prepares any code you send it for evaluation. It doesn't just evaluate the code as-is, it wraps it up in such a way that the symbols defined in that evaluation will get the correct source file and line associated with them (not in ClojureScript, yet).&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn eval-str &amp;#91;{:keys &amp;#91;ns path&amp;#93;} {:keys &amp;#91;conn code line&amp;#93;}&amp;#93;
  &amp;#40;let &amp;#91;path-args-str &amp;#40;when-not &amp;#40;str/blank? path&amp;#41; ;; 1
                        &amp;#40;str &amp;quot; \&amp;quot;&amp;quot; path &amp;quot;\&amp;quot; \&amp;quot;&amp;quot; &amp;#40;last &amp;#40;str/split path #&amp;quot;/&amp;quot;&amp;#41;&amp;#41; &amp;quot;\&amp;quot;&amp;quot;&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;case &amp;#40;:lang conn&amp;#41; ;; 2
      :clj
      &amp;#40;str &amp;quot;
           &amp;#40;do ;; 3
             &amp;#40;ns &amp;quot; &amp;#40;or ns &amp;quot;user&amp;quot;&amp;#41; &amp;quot;&amp;#41; ;; 4
             &amp;#40;let &amp;#91;rdr &amp;#40;-&amp;gt; &amp;#40;java.io.StringReader. \&amp;quot;&amp;quot; &amp;#40;util/escape-quotes code&amp;#41; &amp;quot;\n\&amp;quot;&amp;#41; ;; 5
                           &amp;#40;clojure.lang.LineNumberingPushbackReader.&amp;#41; ;; 6
                           &amp;#40;doto &amp;#40;.setLineNumber &amp;quot; &amp;#40;or line 1&amp;#41; &amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#93;
               &amp;#40;binding &amp;#91;&amp;#42;default-data-reader-fn&amp;#42; tagged-literal&amp;#93;
                 &amp;#40;let &amp;#91;res &amp;#40;. clojure.lang.Compiler &amp;#40;load rdr&amp;quot; path-args-str &amp;quot;&amp;#41;&amp;#41;&amp;#93; ;; 7
                   &amp;#40;cond-&amp;gt; res &amp;#40;seq? res&amp;#41; &amp;#40;doall&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41; ;; 8
           &amp;quot;&amp;#41;

      :cljs
      &amp;#40;str &amp;quot;
           &amp;#40;in-ns '&amp;quot; &amp;#40;or ns &amp;quot;cljs.user&amp;quot;&amp;#41; &amp;quot;&amp;#41; ;; 9
           &amp;#40;do &amp;quot; code &amp;quot;\n&amp;#41;
           &amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is probably the most complex code rendering function in Conjure, let's step through it with the number comments I've added.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Optionally build a string that'll be an argument to &lt;code&gt;&amp;#40;.load clojure.lang.Compiler&amp;#41;&lt;/code&gt;, it sets the path for all &lt;code&gt;def&lt;/code&gt;s within this evaluation.&lt;/li&gt;&lt;li&gt;Build different strings for Clojure (&lt;code&gt;:clj&lt;/code&gt;) and ClojureScript (&lt;code&gt;:cljs&lt;/code&gt;) connections. I'm working to patch prepl to require less of these language specific things but there will always be subtle differences.&lt;/li&gt;&lt;li&gt;Wrap the two parts of Clojure evaluations in a do so we only get one output from the prepl.&lt;/li&gt;&lt;li&gt;Swap the namespace before the evaluation, this is read out of your buffer in Neovim through some interesting process.&lt;/li&gt;&lt;li&gt;Wrap the code to be evaluated in a &lt;code&gt;StringReader&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;Pass that to a &lt;code&gt;LineNumberingPushbackReader&lt;/code&gt; then set the line number to what was specified or 1 by default.&lt;/li&gt;&lt;li&gt;Actually evaluate the code, I use &lt;code&gt;clojure.lang.Compiler&lt;/code&gt; because some of the higher level functions don't let you set this path.&lt;/li&gt;&lt;li&gt;If the result is a sequence, fully realise it with &lt;code&gt;doall&lt;/code&gt; otherwise we'll get weird behavior with lazy sequences that print things.&lt;/li&gt;&lt;li&gt;In ClojureScript we perform two evaluations: Swapping the namespace and evaluating the code in a &lt;code&gt;do&lt;/code&gt;. This means that the code calling this in Conjure needs to throw away the first prepl result since it's just a confirmation that the namespace was changed.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;An evaluation function inside Conjure will execute this template function with the appropriate code and connection information. It'll then pass the result off to your prepl, get the result and deal with it accordingly, showing you any errors. Everything in Conjure works like this to some degree, building up code from template functions, evaluating it then working with the result.&lt;/p&gt;&lt;h2 id=&quot;trade&amp;#95;offs&quot;&gt;Trade offs&lt;/h2&gt;&lt;p&gt;All of this is pretty great but it comes at a cost: We don't have anything like middleware, the &lt;i&gt;only&lt;/i&gt; feature we have available is evaluation. Now some may say that's bad, I think that's totally fine. We can now craft evaluations in such a way that we can do anything we want.&lt;/p&gt;&lt;p&gt;What better API than Clojure itself, we can build any tool imaginable with a REPL that lets us evaluate something. nREPL definitely has benefits by managing our sessions, allowing us to cancel execution and extend the messaging layer itself, but I don't miss them here. I like the fact that I have one infinitely powerful thing, I just have to send it the right code.&lt;/p&gt;&lt;h2 id=&quot;wrap&amp;#95;up&quot;&gt;Wrap up&lt;/h2&gt;&lt;p&gt;I hope this tour has taught you even one small thing about any of these technologies. My main takeaway from this is that nREPL is super powerful, but you have to learn nREPL. The socket REPL and prepl are &lt;em&gt;much&lt;/em&gt; simpler but still allow you to do anything you want, albeit with carefully crafted Clojure code strings.&lt;/p&gt;&lt;p&gt;There's a lot to be said for middleware, it definitely feels like a more proper way to do some things, but so far in my 6-12 months worth of work on Conjure the lack of it hasn't hindered me.&lt;/p&gt;&lt;p&gt;To all of you future or current Clojure tool authors out there, whatever technology you end up building upon, build amazing usable tools that will draw more people to our lovely language.&lt;/p&gt;&lt;p&gt;Let's make everyone else jealous.&lt;/p&gt;
</description>
<pubDate>
Tue, 16 Jul 2019 00:00:00 +0100
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2019-06-28-extending-neovim-with-any-language-mostly-clojure/
</guid>
<link>
https://oli.me.uk/2019-06-28-extending-neovim-with-any-language-mostly-clojure/
</link>
<title>
Extending Neovim with any language (mostly Clojure)
</title>
<description>
&lt;blockquote&gt;&lt;p&gt; This post is mainly to help me plan my talk at &lt;a href='https://www.meetup.com/Vim-London/events/262032144/'&gt;Vim London&lt;/a&gt; on 3rd July 2019 on the same topic. Come along if you can! &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;You may have seen me constantly tweeting about &lt;a href='https://github.com/Olical/conjure'&gt;Conjure&lt;/a&gt; (Neovim Clojure(Script) tooling over prepl) on twitter at &lt;a href='https://twitter.com/OliverCaldwell'&gt;@OliverCaldwell&lt;/a&gt;, what you may not know is that it's my third re-write of the project already. I originally attempted to write it in Rust, then ClojureScript and finally Clojure.&lt;/p&gt;&lt;p&gt;The current state is a little more complex than that though! According to GitHub Conjure is made up of the following:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Clojure &lt;code&gt;81.5%&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Vim script &lt;code&gt;10.3%&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Lua &lt;code&gt;3.7%&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Python &lt;code&gt;2.6%&lt;/code&gt; (only for the &lt;a href='https://github.com/Shougo/deoplete.nvim'&gt;Deoplete&lt;/a&gt; integration)&lt;/li&gt;&lt;li&gt;Shell &lt;code&gt;1.8%&lt;/code&gt; (mostly just for tests and builds)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Let's look into the different ways to write plugins in Neovim (and regular Vim to a slightly lesser extent) and how to avoid the pitfalls of remote plugin development.&lt;/p&gt;&lt;h2 id=&quot;traditional&amp;#95;plugins&quot;&gt;Traditional plugins&lt;/h2&gt;&lt;p&gt;Vim plugins have always been written in Vim Script (or VimL), it's a pretty messy language that's hard to learn and even harder to master. There's a lot of good information out there on the topic (such as &lt;a href='http://stevelosh.com/blog/2011/09/writing-vim-plugins/'&gt;Writing Vim Plugins&lt;/a&gt;) but it's still &lt;i&gt;really&lt;/i&gt; hard.&lt;/p&gt;&lt;p&gt;Not only is it hard to actually learn and use, you only get one thread which happens to be the same one as Vim's UI. This means if you have a CPU intensive plugin it'll noticeably block Vim's UI. To make matters worse, VimL is pretty slow in the first place so it's &lt;i&gt;easy&lt;/i&gt; to write something sluggish.&lt;/p&gt;&lt;p&gt;Despite all of this, it's still required in some places and always will be so it's worth understanding to some extent. Here's an example function that calculates Fibonacci numbers to show you some of the language.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;viml&quot;&gt;function! s:fib&amp;#40;n&amp;#41;
  let l:a = 0
  let l:b = 1
  let l:t = 0

  let l:i = 0

  while i &amp;lt; a:n
    let t = a + b
    let a = b
    let b = t
    let i += 1
  endwhile

  return a
endfunction

echo s:fib&amp;#40;10&amp;#41;
&amp;quot; =&amp;gt; 55
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We usually store our code inside files under special directory names at the root of a repository.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;plugin/foo.vim&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;autoload/foo.vim&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;doc/foo.txt&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;We can then depend on the plugin via a plugin manager such as &lt;a href='https://github.com/junegunn/vim-plug'&gt;vim-plug&lt;/a&gt; which will load the files for us. &lt;a href='http://learnvimscriptthehardway.stevelosh.com/'&gt;Learn Vimscript the Hard Way&lt;/a&gt; is an invaluable resource for writing the VimL parts of your plugins.&lt;/p&gt;&lt;h2 id=&quot;lua&amp;#95;enters&amp;#95;the&amp;#95;fray!&quot;&gt;Lua enters the fray!&lt;/h2&gt;&lt;p&gt;Amazingly, Neovim has &lt;a href='https://luajit.org/'&gt;LuaJIT&lt;/a&gt; built into the core binary. This means we have full &lt;a href='https://www.lua.org/'&gt;Lua&lt;/a&gt; support natively within the editor without any overhead of communicating to external processes, it's &lt;i&gt;within&lt;/i&gt; the process.&lt;/p&gt;&lt;p&gt;This should mean you can block the UI by running a lot of Lua, something I haven't tried. Luckily, LuaJIT is one of the fastest languages out there (&lt;a href='https://www.quora.com/Why-is-Lua-so-fast'&gt;Why is Lua so fast?&lt;/a&gt;), just look at these (possibly contrived) benchmarks!&lt;/p&gt;&lt;ul&gt;&lt;li&gt;22.29s C&lt;/li&gt;&lt;li&gt;23.29s LuaJIT&lt;/li&gt;&lt;li&gt;26.33s PyPy&lt;/li&gt;&lt;li&gt;54.30s Java&lt;/li&gt;&lt;li&gt;92.94s NodeJS&lt;/li&gt;&lt;li&gt;159.93s Lua&lt;/li&gt;&lt;li&gt;416.55s Python&lt;/li&gt;&lt;li&gt;????.??s Vim Script ðŸ¤”&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt; So, I think we can say Lua is fucking fast for a script language. &lt;/p&gt;&lt;p&gt; &amp;mdash; Hanno Behrens &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Lua gives us the benefit of a polished and &lt;i&gt;fast&lt;/i&gt; language without leaving Neovim. Here's how neat Fibonacci looks in Lua.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;lua&quot;&gt;function fib&amp;#40;n&amp;#41;
  a, b = 0, 1

  for i = 1, n do
    a, b = b, a + b
  end

  return a   
end

print&amp;#40;fib&amp;#40;10&amp;#41;&amp;#41;
-- =&amp;gt; 55
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That's so much easier to work with and will run so very much faster. We'll still need to use some VimL to write our commands and mappings but now we can call through to our clever Lua functions which have access to the entirety of Neovim's API.&lt;/p&gt;&lt;p&gt;Here's a tiny extract from Conjure's Lua module, &lt;code&gt;lua/conjure.lua&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;lua&quot;&gt;local conjure = {}

-- ...

-- Close the log window if it's open in the current tabpage.
function conjure.close&amp;#95;log&amp;#40;log&amp;#95;buf&amp;#95;name&amp;#41;
  local match = find&amp;#95;log&amp;#40;log&amp;#95;buf&amp;#95;name&amp;#41;
  if match.win then
    local win&amp;#95;number = vim.api.nvim&amp;#95;win&amp;#95;get&amp;#95;number&amp;#40;match.win&amp;#41;
    vim.api.nvim&amp;#95;command&amp;#40;win&amp;#95;number .. &amp;quot;close!&amp;quot;&amp;#41;
  end
end

return conjure
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;you&amp;#95;can&amp;#95;&lt;i&gt;technically&lt;/i&gt;&amp;#95;compile&amp;#95;javascript&amp;#95;to&amp;#95;lua...&quot;&gt;You can &lt;i&gt;technically&lt;/i&gt; compile JavaScript to lua...&lt;/h3&gt;&lt;p&gt;Using something like &lt;a href='https://github.com/PaulBernier/castl'&gt;castl&lt;/a&gt; or &lt;a href='https://github.com/wizzard0/js2lua'&gt;js2lua&lt;/a&gt; you can compile some JavaScript to Lua which could come in pretty handy. What they probably didn't intend was for me to compile &lt;a href='https://clojurescript.org/'&gt;ClojureScript&lt;/a&gt; to JavaScript and then to Lua.&lt;/p&gt;&lt;p&gt;Now if you think that concept is scary, what's more terrifying is that it actually &lt;em&gt;worked&lt;/em&gt;, sort of. I got a &quot;Hello, World!&quot; out of it but it exploded when I tried to use &lt;code&gt;core.async&lt;/code&gt; or self hosting. It mostly complained about too many local variables, apparently LuaJIT has an upper limit on that.&lt;/p&gt;&lt;p&gt;Can you imagine self hosted ClojureScript running in Neovim directly? Now stop. It's an awful idea and will lead to so much pain further down the line when something breaks subtly, here be dragons. You have been warned.&lt;/p&gt;&lt;p&gt;Worryingly, it almost worked. Check out &lt;a href='https://github.com/Olical/cljs-lua-experiment'&gt;cljs-lua-experiment&lt;/a&gt; to see what I was playing with.&lt;/p&gt;&lt;h2 id=&quot;going&amp;#95;remote&quot;&gt;Going remote&lt;/h2&gt;&lt;p&gt;Neovim supports the concept of &lt;a href='https://neovim.io/doc/user/remote_plugin.html'&gt;remote plugins&lt;/a&gt;. These are programs started by Neovim as a child process that it communicates with over msgpack RPC (through &lt;code&gt;stdio&lt;/code&gt;) allowing use of the same API that Lua has access to, albeit with interprocess communication overhead.&lt;/p&gt;&lt;p&gt;The main downside to this is that every request and response has a round trip time as the message is encoded, decoded and handled, this can get noticeable fairly quickly. The upside is that we're no longer tied to Neovim's UI thread, we can spawn our own threads in whatever language we see fit!&lt;/p&gt;&lt;p&gt;In my case, this means a Clojure process doing whatever it wants and calling back to Neovim when it needs some information or wants to change something within the editor such as displaying virtual text or appending some lines.&lt;/p&gt;&lt;h3 id=&quot;regular&amp;#95;vim?&quot;&gt;Regular Vim?&lt;/h3&gt;&lt;p&gt;I think Vim 8 introduced a similar system of remote plugins (possibly called &quot;jobs&quot;?) but I haven't looked into it too much. As far as I can tell it doesn't give you a rich API like Neovim, nor any Lua, so you end up rendering VimL strings to be sent across to the editor.&lt;/p&gt;&lt;p&gt;I can see this working to an extent but I would imagine it'll get pretty awkward as you try to batch requests or optimise your calls. I did consider supporting Vim 8 in Conjure but decided the API is so different that I'll end up spending quite a long time just keeping the API shim working correctly across both systems.&lt;/p&gt;&lt;p&gt;If your requirements are quite simple, try to support both systems. If you're building something pretty interactive that requires a lot of manipulation of buffers and windows then maybe just stick to Neovim, they've clearly designed the API with this in mind.&lt;/p&gt;&lt;h3 id=&quot;experiments&amp;#95;with&amp;#95;rust&quot;&gt;Experiments with Rust&lt;/h3&gt;&lt;p&gt;Before I tried to write the initial version of Conjure in Rust I played about with a toy plugin called &lt;a href='https://github.com/Olical/neofib'&gt;neofib&lt;/a&gt; that calculated Fibonacci numbers. Here's how it's core function looks though since we're on the topic of Fibonacci language comparisons.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;pub fn fib&amp;#40;n: u64&amp;#41; -&amp;gt; u64 {
    let mut a = 0;
    let mut b = 1;

    for &amp;#95; in 0..n {
        let t = a + b;
        a = b;
        b = t;
    }

    a
}

fib&amp;#40;10&amp;#41;
// =&amp;gt; 55
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That project demonstrates remote plugins in Rust using &lt;a href='https://github.com/daa84/neovim-lib'&gt;neovim-lib&lt;/a&gt; as a sort of framework. Once I got around to attempting Conjure in Rust I got tangled up in Rust as a language as well as managing so many different asynchronous requests as my first real Rust project.&lt;/p&gt;&lt;p&gt;Ultimately the final nail in the coffin of my Rust attempt was that the EDN parsing wasn't good enough for my needs. I needed a &lt;i&gt;real&lt;/i&gt; Clojure implementation to parse and format the results I was getting out of the &lt;a href='https://oli.me.uk/2019-03-22-clojure-socket-prepl-cookbook/'&gt;socket prepl&lt;/a&gt;. I think if you don't need to parse a lot of Clojure and you're comfortable in Rust then it's a fine choice for writing complex remote plugins.&lt;/p&gt;&lt;h3 id=&quot;dabbling&amp;#95;with&amp;#95;clojurescript&quot;&gt;Dabbling with ClojureScript&lt;/h3&gt;&lt;p&gt;It didn't last long, but I did try writing Conjure as a remote plugin running on top of node in ClojureScript.&lt;/p&gt;&lt;p&gt;I killed that attempt because I &lt;del&gt;don't think JavaScript is that great&lt;/del&gt; really struggled to manage all of the asynchronous complexity on the node platform through promises. I wanted a language that ate asynchronous problems for breakfast and could parse Clojure or ClojureScript with ease. I wanted my beloved Clojure on the JVM.&lt;/p&gt;&lt;h3 id=&quot;settling&amp;#95;down&amp;#95;with&amp;#95;clojure&quot;&gt;Settling down with Clojure&lt;/h3&gt;&lt;p&gt;The iteration you see today on &lt;a href='https://github.com/Olical/conjure'&gt;Conjure's repo&lt;/a&gt; is a Clojure JVM process that sits between your Neovim and your various Clojure project JVMs. It handles requests you initiate through Neovim, evaluates the right thing on the right prepl connection then manipulates your Neovim UI to display the results.&lt;/p&gt;&lt;p&gt;What's interesting about this particular project is that Conjure is used to build Conjure, so I edit the source in Neovim and can use the development version to develop itself. This does mean I've broken &lt;code&gt;eval&lt;/code&gt; in the past which meant I couldn't &lt;code&gt;eval&lt;/code&gt; the fixed &lt;code&gt;eval&lt;/code&gt; (luckily &quot;load the current file from disk&quot; still worked...). It's a weird feeling, growing the tool with the tool, but it's extremely &lt;i&gt;lispy&lt;/i&gt; and works so well. The feedback loop is ~0.&lt;/p&gt;&lt;h3 id=&quot;performance?&quot;&gt;Performance?&lt;/h3&gt;&lt;p&gt;Writing your plugins in a remote process is fantastic in so many ways. You get the power of whatever language and ecosystem you use to drive your favourite text editor!&lt;/p&gt;&lt;p&gt;The limit to this is that you need to encode and decode msgpack RPC payloads to get anything done, this is okay if you keep it to a minimum but won't allow you to execute something on every key press, for example. So as your functions grow in complexity and require more and more communication you'll start to see things slow down.&lt;/p&gt;&lt;p&gt;The way I worked around this is by writing most of Conjure in Clojure with atomically batched requests to Neovim for most of the work. I then fall through to calling pre-loaded Lua functions inside Neovim where the API calls would be noticeably slow.&lt;/p&gt;&lt;p&gt;That &lt;code&gt;conjure.close&amp;#95;log&lt;/code&gt; function I mentioned earlier ends up doing a lot of querying and filtering to find the Conjure log window (if it's open) in a way that doesn't require storing any state. I call it from Conjure like so.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn &amp;#94;:dynamic call
  &amp;quot;Simply a thin nvim specific wrapper around rpc/request.&amp;quot;
  &amp;#91;req&amp;#93;
  &amp;#40;let &amp;#91;{:keys &amp;#91;error result&amp;#93; :as resp} &amp;#40;rpc/request req&amp;#41;&amp;#93;
    &amp;#40;when error
      &amp;#40;log/error &amp;quot;Error while making nvim call&amp;quot; req &amp;quot;-&amp;gt;&amp;quot; resp&amp;#41;&amp;#41;
    result&amp;#41;&amp;#41;

&amp;#40;defn execute-lua &amp;#91;code &amp;amp; args&amp;#93;
  {:method :nvim-execute-lua
   :params &amp;#91;code args&amp;#93;}&amp;#41;

&amp;#40;defn call-lua-function
  &amp;quot;Execute Conjure lua functions.&amp;quot;
  &amp;#91;fn-name &amp;amp; args&amp;#93;
  &amp;#40;-&amp;gt;&amp;gt; &amp;#40;apply execute-lua
              &amp;#40;str &amp;quot;return require&amp;#40;'conjure'&amp;#41;.&amp;quot; &amp;#40;util/kw-&amp;gt;snake fn-name&amp;#41; &amp;quot;&amp;#40;...&amp;#41;&amp;quot;&amp;#41;
              args&amp;#41;
       &amp;#40;call&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn call-lua-function
  &amp;quot;Execute Conjure lua functions.&amp;quot;
  &amp;#91;fn-name &amp;amp; args&amp;#93;
  &amp;#40;-&amp;gt;&amp;gt; &amp;#40;apply execute-lua
              &amp;#40;str &amp;quot;return require&amp;#40;'conjure'&amp;#41;.&amp;quot; &amp;#40;util/kw-&amp;gt;snake fn-name&amp;#41; &amp;quot;&amp;#40;...&amp;#41;&amp;quot;&amp;#41;
              args&amp;#41;
       &amp;#40;call&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn close-log
  &amp;quot;Closes the log window. In other news: Bear shits in woods.&amp;quot;
  &amp;#91;&amp;#93;
  &amp;#40;call-lua-function :close-log log-buffer-name&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I essentially build up data structures that can either be called on their own or atomically alongside other requests. In this case, it's building one request that executes some Lua code which executes a function in the &lt;code&gt;conjure&lt;/code&gt; module.&lt;/p&gt;&lt;h2 id=&quot;actually&amp;#95;doing&amp;#95;this?&quot;&gt;Actually doing this?&lt;/h2&gt;&lt;p&gt;I highly recommend you dig through the source of &lt;a href='https://github.com/Olical/conjure'&gt;Conjure&lt;/a&gt; and &lt;a href='https://github.com/Olical/neofib'&gt;neofib&lt;/a&gt; to see how I implemented the underlying communication with Neovim. Once you've worked that out the rest is entirely up to you, just bear in mind my warning about performance.&lt;/p&gt;&lt;p&gt;You shouldn't put too much strain on the &lt;code&gt;stdio&lt;/code&gt; msgpack RPC layer, try to do as much as you can remotely then occasionally ask Neovim to update something. Ideally through a Lua function since that'll run the fastest and be extremely easy to write.&lt;/p&gt;&lt;p&gt;I hope this overview has been helpful!&lt;/p&gt;
</description>
<pubDate>
Fri, 28 Jun 2019 00:00:00 +0100
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2019-03-22-clojure-socket-prepl-cookbook/
</guid>
<link>
https://oli.me.uk/2019-03-22-clojure-socket-prepl-cookbook/
</link>
<title>
Clojure socket prepl cookbook
</title>
<description>
&lt;blockquote&gt;&lt;p&gt; This post has been translated into &lt;a href='http://softdroid.net/povarennaya-kniga-clojure-socket-prepl'&gt;Russian&lt;/a&gt; by Vlad at &lt;a href='http://softdroid.net/'&gt;Softdroid&lt;/a&gt;. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;The socket prepl is a relatively new tool built into Clojure that allows you to REPL into a running application. It's essentially a much simpler &quot;official&quot; approach to the problem that nREPL also happens to solve. If your current nREPL tooling is working well for you then congratulations, carry on, this post won't be of much use to you.&lt;/p&gt;&lt;p&gt;I've been developing Clojure(Script) tooling for &lt;a href='https://neovim.io/'&gt;Neovim&lt;/a&gt; over a prepl connection for the past six months or so (involving three attempts in different languages). It's called &lt;a href='https://github.com/Olical/conjure'&gt;Conjure&lt;/a&gt;, you may have seen me constantly talking about it &lt;a href='https://twitter.com/OliverCaldwell'&gt;over on twitter&lt;/a&gt;. Since writing this has involved prepling into all sorts of environments and applications I ended up learning quite a few recipes for starting your prepls.&lt;/p&gt;&lt;p&gt;This post is intended to be a reference for various socket prepl techniques, I hope you find them useful!&lt;/p&gt;&lt;h2 id=&quot;from&amp;#95;the&amp;#95;cli&quot;&gt;From the CLI&lt;/h2&gt;&lt;p&gt;You can start a prepl from the Clojure CLI without your program being aware of it at all.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;clj -J-Dclojure.server.jvm=&amp;quot;{:port 5555 :accept clojure.core.server/io-prepl}&amp;quot; \
    -J-Dclojure.server.node=&amp;quot;{:port 5556 :accept cljs.server.node/prepl}&amp;quot; \
    -J-Dclojure.server.browser=&amp;quot;{:port 5557 :accept cljs.server.browser/prepl}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This starts up three prepls then drops into a regular REPL session. The REPL session and &lt;code&gt;jvm&lt;/code&gt; prepl share the same environment so changes in the CLI REPL affect the prepl and the other way around.&lt;/p&gt;&lt;p&gt;The &lt;code&gt;node&lt;/code&gt; and &lt;code&gt;browser&lt;/code&gt; prepls each start up their own environments upon eval. Give it a go! Start up the prepls then use &lt;a href='https://en.wikipedia.org/wiki/Netcat'&gt;netcat&lt;/a&gt; (or similar) to send them code.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;# JVM
nc localhost 5555
&amp;#40;+ 10 10&amp;#41;
{:tag :ret, :val &amp;quot;20&amp;quot;, :ns &amp;quot;user&amp;quot;, :ms 2, :form &amp;quot;&amp;#40;+ 10 10&amp;#41;&amp;quot;}
:repl/quit

# node
nc localhost 5556
&amp;#40;+ 10 10&amp;#41;
{:tag :ret, :val &amp;quot;20&amp;quot;, :ns &amp;quot;cljs.user&amp;quot;, :ms 9, :form &amp;quot;&amp;#40;+ 10 10&amp;#41;&amp;quot;}
:repl/quit

# browser
nc localhost 5557
{:tag :ret, :val &amp;quot;20&amp;quot;, :ns &amp;quot;cljs.user&amp;quot;, :ms 51, :form &amp;quot;&amp;#40;+ 10 10&amp;#41;&amp;quot;}
:repl/quit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The resulting data structures you see are the prepl part, that's what prepl does, wraps things in a predictable data structure that tools like &lt;a href='https://github.com/Olical/conjure'&gt;Conjure&lt;/a&gt; can parse and work with.&lt;/p&gt;&lt;h2 id=&quot;from&amp;#95;your&amp;#95;code&quot;&gt;From your code&lt;/h2&gt;&lt;p&gt;You don't have to start things from the CLI, sometimes that's not practical. For example, at work we're running everything through &lt;code&gt;lein&lt;/code&gt; and I wasn't totally sure how the arguments would work with that, so I just added the code next to where we start our nREPL server.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns my.project.prepl
  &amp;#40;:require &amp;#91;clojure.core.server :as server&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn start-prepl! &amp;#91;{:keys &amp;#91;bind port name&amp;#93;}&amp;#93;
  &amp;#40;server/start-server {:accept 'clojure.core.server/io-prepl
                        :address bind
                        :port port
                        :name name}&amp;#41;&amp;#41;

;; In some -main fn somewhere...
&amp;#40;start-prepl! {:bind &amp;quot;localhost&amp;quot;, :port 5555, :name &amp;quot;jvm&amp;quot;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is &lt;i&gt;essentially&lt;/i&gt; the same as the first line in the CLI only approach, you can swap out the &lt;code&gt;:accept&lt;/code&gt; function for &lt;code&gt;cljs.server.node/prepl&lt;/code&gt; for example and get a node prepl.&lt;/p&gt;&lt;h2 id=&quot;gotcha:&amp;#95;multiple&amp;#95;node&amp;#95;prepls&quot;&gt;Gotcha: Multiple node prepls&lt;/h2&gt;&lt;p&gt;Something I got caught on and eventually worked out was why starting multiple node prepls on different ports conflicted with each other. Well it turns out there's a &lt;a href='https://github.com/clojure/clojurescript/blob/230e46aee2c9b76e426e85865ab8930c4c26e14f/src/main/clojure/cljs/server/node.clj#L27'&gt;hard coded port&lt;/a&gt; (49001, if you're interested) inside the node prepl source. Luckily this is just a default and you can configure it pretty easily.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;# Start these in two terminals and nc into both, only one will work.
clj -J-Dclojure.server.nodea=&amp;quot;{:port 6661 :accept cljs.server.node/prepl}&amp;quot;
clj -J-Dclojure.server.nodeb=&amp;quot;{:port 6662 :accept cljs.server.node/prepl}&amp;quot;

# You can set the args the accept function receives though.
# This means we can configure a port for the cljs.server.node/prepl function.
clj -J-Dclojure.server.nodea=&amp;quot;{:port 6661 :accept cljs.server.node/prepl}&amp;quot;
clj -J-Dclojure.server.nodeb=&amp;quot;{:port 6662 :accept cljs.server.node/prepl, :args &amp;#91;{:env-opts {:port 48000}}&amp;#93;}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With this configured you should be able to run multiple node prepls on one machine at the same time.&lt;/p&gt;&lt;h2 id=&quot;figwheel&amp;#95;and&amp;#95;prepl&quot;&gt;Figwheel and prepl&lt;/h2&gt;&lt;p&gt;For regular Clojure projects, the information above should be enough for all situations. For ClojureScript however it's rare that you would be developing &lt;i&gt;without&lt;/i&gt; figwheel, it's not an edge case, it's the norm. If you start up a browser prepl though that's going to launch another tab to evaluate in, it doesn't share the same context as figwheel.&lt;/p&gt;&lt;p&gt;Thankfully there's a way to have figwheel reloading your ClojureScript as well as prepl into that figwheel environment! I got this working with &lt;code&gt;figwheel-main&lt;/code&gt; and a few tips from Bruce himself over Slack and Twitter (&lt;a href='https://twitter.com/bhauman'&gt;@bhauman&lt;/a&gt;). Here's a minimal &lt;code&gt;deps.edn&lt;/code&gt; for this technique.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:paths &amp;#91;&amp;quot;src&amp;quot; &amp;quot;target&amp;quot;&amp;#93;
 :deps {org.clojure/clojure {:mvn/version &amp;quot;1.10.0&amp;quot;}
        org.clojure/clojurescript {:mvn/version &amp;quot;1.10.520&amp;quot;}
        com.bhauman/figwheel-main {:mvn/version &amp;quot;0.2.0&amp;quot;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And a small amount of code to start up figwheel then hook the prepl into figwheel's &lt;code&gt;repl-env&lt;/code&gt;. This means you can send code to the socket prepl but it'll rely on figwheel for compiling that ClojureScript and getting the resulting JavaScript into the browser (or node process!) for evaluation.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns pfig.main
  &amp;#40;:require &amp;#91;figwheel.main.api :as fig&amp;#93;
            &amp;#91;clojure.core.server :as server&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn -main &amp;#91;&amp;#93;
  &amp;#40;figwheel.main.api/start
    {:id &amp;quot;dev&amp;quot;
     :options {:main 'pfig.test}
     :config {:watch-dirs &amp;#91;&amp;quot;src&amp;quot;&amp;#93;
              :mode :serve}}&amp;#41;

  &amp;#40;println &amp;quot;=== START PREPL&amp;quot;&amp;#41;
  &amp;#40;server/start-server {:accept 'cljs.core.server/io-prepl
                        :address &amp;quot;127.0.0.1&amp;quot;
                        :port 6776
                        :name &amp;quot;pfig&amp;quot;
                        :args &amp;#91;:repl-env &amp;#40;fig/repl-env &amp;quot;dev&amp;quot;&amp;#41;&amp;#93;}&amp;#41;

  &amp;#40;fig/cljs-repl &amp;quot;dev&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I'm using the newer figwheel-main but this is definitely doable in other iterations of figwheel, the API might just be a little different.&lt;/p&gt;&lt;h2 id=&quot;:repl/quit&quot;&gt;:repl/quit&lt;/h2&gt;&lt;p&gt;Got any more tips or comments? Say hi on twitter, I'm &lt;a href='https://twitter.com/OliverCaldwell'&gt;@OliverCaldwell&lt;/a&gt;. I hope you've learned something new, have a great day!&lt;/p&gt;&lt;h2 id=&quot;edit&amp;#95;2019-03-23&quot;&gt;Edit 2019-03-23&lt;/h2&gt;&lt;p&gt;JosÃ© Luis Lafuente (&lt;a href='https://twitter.com/jlesquembre'&gt;@jlesquembre&lt;/a&gt;) &lt;a href='https://twitter.com/jlesquembre/status/1109461402069225472'&gt;pointed out&lt;/a&gt; that you can put these prepl JVM args in your &lt;code&gt;deps.edn&lt;/code&gt; file but you're not allowed to use spaces which makes Clojure maps tricky to write. You can get around this issue by replacing the spaces in the string with commas since Clojure treats commas as whitespace anyway.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:deps {}

 :aliases
 {:prepl {:jvm-opts &amp;#91;&amp;quot;-Dclojure.server.repl={:port,40404,:accept,clojure.core.server/io-prepl}&amp;quot;&amp;#93;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This example is taken from &lt;a href='https://github.com/seancorfield/dot-clojure/blob/c4a98f4a62b3caba92b1cd05b897eadad80e4a07/deps.edn#L55-L56'&gt;github.com/seancorfield/dot-clojure&lt;/a&gt;.&lt;/p&gt;&lt;h2 id=&quot;edit&amp;#95;2019-07-18&quot;&gt;Edit 2019-07-18&lt;/h2&gt;&lt;p&gt;&lt;a href='https://github.com/thecontinium'&gt;thecontinium&lt;/a&gt; over in issue &lt;a href='https://github.com/Olical/conjure/issues/49'&gt;#49&lt;/a&gt; of Conjure got a prepl launched from Leiningen via &lt;code&gt;&amp;#126;/.lein/profiles.clj&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:repl
 {:repl-options
  {:init &amp;#40;clojure.core.server/start-server {:accept 'clojure.core.server/io-prepl
                                            :address &amp;quot;localhost&amp;quot;
                                            :port 55555
                                            :name &amp;quot;lein&amp;quot;}&amp;#41;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Which they could connect to Conjure with a &lt;code&gt;.conjure.edn&lt;/code&gt; containing the following.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:conns {:lein {:port 55555}}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Neat!&lt;/p&gt;
</description>
<pubDate>
Fri, 22 Mar 2019 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2018-10-12-wake-word-detection-with-clojure-or-java/
</guid>
<link>
https://oli.me.uk/2018-10-12-wake-word-detection-with-clojure-or-java/
</link>
<title>
Wake word detection with Clojure (or Java)
</title>
<description>
&lt;blockquote&gt;&lt;p&gt; Hello there, intrepid Clojurian. If you don't want to follow along with this post and just want to copy some code, go to &lt;a href='https://github.com/Olical/clojure-wake-word-detection'&gt;Olical/clojure-wake-word-detection&lt;/a&gt;. Enjoy! &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;If you follow me on &lt;a href='https://twitter.com/OliverCaldwell'&gt;twitter&lt;/a&gt; or &lt;a href='https://github.com/Olical/'&gt;GitHub&lt;/a&gt; you've probably seen me working on &lt;a href='https://github.com/Olical/snowball'&gt;Snowball&lt;/a&gt;, a voice activated &lt;a href='https://discordapp.com/'&gt;Discord&lt;/a&gt; bot written in &lt;a href='https://clojure.org/'&gt;Clojure&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;It works fairly well and allows my friends and I to move people around channels and control our music bot over voice while we're in a game. For example:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; O: Hey Snowball &lt;/p&gt;&lt;p&gt; S: Hey, Olical &lt;/p&gt;&lt;p&gt; O: Pause the music &lt;/p&gt;&lt;p&gt; S: Sure thing &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;The voice control has a few steps to it:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Receive all audio from a Discord voice channel and store per-user streams of audio data.&lt;/li&gt;&lt;li&gt;When someone says something and then stops speaking we need to check that audio for the wake phrase &quot;hey snowball&quot;.&lt;/li&gt;&lt;li&gt;If we spot the wake phrase we then need to wait for them to say another sentence which we'll treat as a command.&lt;/li&gt;&lt;li&gt;Once we've got that second phrase it can be sent off to Google Cloud Platform (in my case) for speech recognition.&lt;/li&gt;&lt;li&gt;The program can then act on that command.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Sending audio off to Google from Clojure or Java is actually pretty straightforward and well documented, you can also check out &lt;a href='https://github.com/Olical/snowball/blob/b8be304046e98c2c082fa6f583ebf9950bf412ac/src/clojure/snowball/comprehension.clj#L139-L172'&gt;snowball.comprehension&lt;/a&gt; to see how I managed it.&lt;/p&gt;&lt;p&gt;The part that didn't seem to exist was the wake word detection, I had to write a little C and some Java to get it working. Here's what I ended up with so you can use it in your projects.&lt;/p&gt;&lt;h2 id=&quot;tooling&quot;&gt;Tooling&lt;/h2&gt;&lt;p&gt;I hunted high and low for a JVM compatible wake word detector, I tried to use &lt;a href='https://cmusphinx.github.io/'&gt;cmusphinx&lt;/a&gt; for longer than I'd like to admit and couldn't get anything working. The one time I had it processing audio it was wildly inaccurate and hogging my CPU, I was probably doing something massively wrong.&lt;/p&gt;&lt;p&gt;I finally stumbled across &lt;a href='https://github.com/Picovoice/Porcupine'&gt;Porcupine&lt;/a&gt; and can highly recommend it, it's specialised for this job and works great. The only problem was it didn't have any support for JVM on the desktop, there were some Android bindings but that's all. I wrote a little C and some Java so my Clojure could talk to Porcupine.&lt;/p&gt;&lt;p&gt;Before I get to that though, let's set up a little &lt;code&gt;Makefile&lt;/code&gt; that will fetch Porcupine (watch out, the repository is around 3GB) and configure a wake phrase.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;makefile&quot;&gt;WAKE&amp;#95;PHRASE := hey porcupine

wake-word-engine: wake-word-engine/Porcupine wake-word-engine/wake&amp;#95;phrase.ppn

wake-word-engine/Porcupine:
	mkdir -p wake-word-engine
	cd wake-word-engine &amp;amp;&amp;amp; git clone git@github.com:Picovoice/Porcupine.git

wake-word-engine/wake&amp;#95;phrase.ppn: wake-word-engine/Porcupine
	cd wake-word-engine/Porcupine &amp;amp;&amp;amp; tools/optimizer/linux/x86&amp;#95;64/pv&amp;#95;porcupine&amp;#95;optimizer -r resources/ -w &amp;quot;$&amp;#40;WAKE&amp;#95;PHRASE&amp;#41;&amp;quot; -p linux -o ../
	mv &amp;quot;wake-word-engine/$&amp;#40;WAKE&amp;#95;PHRASE&amp;#41;&amp;#95;linux.ppn&amp;quot; wake-word-engine/wake&amp;#95;phrase.ppn
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When we run &lt;code&gt;make&lt;/code&gt; it'll download the Porcupine repo (if we don't have it already) and build the &lt;code&gt;.ppn&lt;/code&gt; file. We use this file to configure Porcupine at runtime with the desired wake phrase. Run this so that we have Porcupine downloaded and ready to use.&lt;/p&gt;&lt;h2 id=&quot;bindings&quot;&gt;Bindings&lt;/h2&gt;&lt;p&gt;We have Porcupine but we have no way for the JVM to talk to it, it's a native library written in closed source C, luckily they expose enough through shared libraries that we can easily write our own bindings. You may want to extend the following Java and C yourself, but this was enough for me.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; I've chosen &lt;code&gt;wakeup&lt;/code&gt; as a root namespace but obviously you could use something else. In Snowball I have &lt;code&gt;snowball.porcupine&lt;/code&gt; instead of &lt;code&gt;wakeup.porcupine&lt;/code&gt;, I just thought I'd make it generic for this post. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Place this in &lt;code&gt;src/java/wakeup/porcupine/Porcupine.java&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;// Copied and modified from the Porcupine project Android binding.
// https://github.com/Picovoice/Porcupine

package wakeup.porcupine;

public class Porcupine {
    private final long object;

    static {
        System.loadLibrary&amp;#40;&amp;quot;pv&amp;#95;porcupine&amp;quot;&amp;#41;;
    }

    public Porcupine&amp;#40;String modelFilePath, String keywordFilePath, float sens&amp;#41; throws Exception {
        try {
            object = init&amp;#40;modelFilePath, keywordFilePath, sens&amp;#41;;
        } catch &amp;#40;Exception e&amp;#41; {
            throw new Exception&amp;#40;e&amp;#41;;
        }
    }

    public boolean processFrame&amp;#40;short&amp;#91;&amp;#93; pcm&amp;#41; throws Exception {
        try {
            return process&amp;#40;object, pcm&amp;#41;;
        } catch &amp;#40;Exception e&amp;#41; {
            throw new Exception&amp;#40;e&amp;#41;;
        }
    }

    public void delete&amp;#40;&amp;#41; {
        delete&amp;#40;object&amp;#41;;
    }

    public native int getFrameLength&amp;#40;&amp;#41;;

    public native int getSampleRate&amp;#40;&amp;#41;;

    private native long init&amp;#40;String modelFilePath, String keywordFilePaths, float sensitivitie&amp;#41;;

    private native boolean process&amp;#40;long object, short&amp;#91;&amp;#93; pcm&amp;#41;;

    private native void delete&amp;#40;long object&amp;#41;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Place this in &lt;code&gt;src/c/porcupine.c&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pv&amp;#95;porcupine.h&amp;gt;
#include &amp;lt;wakeup&amp;#95;porcupine&amp;#95;Porcupine.h&amp;gt;

JNIEXPORT jlong JNICALL Java&amp;#95;wakeup&amp;#95;porcupine&amp;#95;Porcupine&amp;#95;init
  &amp;#40;JNIEnv &amp;#42;env, jobject obj, jstring model&amp;#95;raw, jstring keyword&amp;#95;raw, jfloat sens&amp;#41; {
   const char &amp;#42;model = &amp;#40;&amp;#42;env&amp;#41;-&amp;gt;GetStringUTFChars&amp;#40;env, model&amp;#95;raw, 0&amp;#41;;
   const char &amp;#42;keyword = &amp;#40;&amp;#42;env&amp;#41;-&amp;gt;GetStringUTFChars&amp;#40;env, keyword&amp;#95;raw, 0&amp;#41;;
   pv&amp;#95;porcupine&amp;#95;object&amp;#95;t &amp;#42;handle;

   const pv&amp;#95;status&amp;#95;t status = pv&amp;#95;porcupine&amp;#95;init&amp;#40;model, keyword, sens, &amp;amp;handle&amp;#41;;

   if &amp;#40;status != PV&amp;#95;STATUS&amp;#95;SUCCESS&amp;#41; {
       printf&amp;#40;&amp;quot;Error: Failed to initialise the Porcupine instance.&amp;quot;&amp;#41;;
   }

   &amp;#40;&amp;#42;env&amp;#41;-&amp;gt;ReleaseStringUTFChars&amp;#40;env, model&amp;#95;raw, model&amp;#41;;
   &amp;#40;&amp;#42;env&amp;#41;-&amp;gt;ReleaseStringUTFChars&amp;#40;env, keyword&amp;#95;raw, keyword&amp;#41;;

   return &amp;#40;long&amp;#41;handle;
}

JNIEXPORT void JNICALL Java&amp;#95;wakeup&amp;#95;porcupine&amp;#95;Porcupine&amp;#95;delete
  &amp;#40;JNIEnv &amp;#42;env, jobject obj, jlong handle&amp;#41; {
  pv&amp;#95;porcupine&amp;#95;delete&amp;#40;&amp;#40;pv&amp;#95;porcupine&amp;#95;object&amp;#95;t&amp;#42;&amp;#41;handle&amp;#41;;
}

JNIEXPORT jint JNICALL Java&amp;#95;wakeup&amp;#95;porcupine&amp;#95;Porcupine&amp;#95;getFrameLength
  &amp;#40;JNIEnv &amp;#42;env, jobject obj&amp;#41; {
  return pv&amp;#95;porcupine&amp;#95;frame&amp;#95;length&amp;#40;&amp;#41;;
}

JNIEXPORT jint JNICALL Java&amp;#95;wakeup&amp;#95;porcupine&amp;#95;Porcupine&amp;#95;getSampleRate
  &amp;#40;JNIEnv &amp;#42;env, jobject obj&amp;#41; {
  return pv&amp;#95;sample&amp;#95;rate&amp;#40;&amp;#41;;
}

JNIEXPORT jboolean JNICALL Java&amp;#95;wakeup&amp;#95;porcupine&amp;#95;Porcupine&amp;#95;process
  &amp;#40;JNIEnv &amp;#42;env, jobject obj, jlong handle, jshortArray pcm&amp;#95;raw&amp;#41; {
  jshort &amp;#42;pcm = &amp;#40;&amp;#42;env&amp;#41;-&amp;gt;GetShortArrayElements&amp;#40;env, pcm&amp;#95;raw, 0&amp;#41;;
  bool result;

  pv&amp;#95;porcupine&amp;#95;process&amp;#40;&amp;#40;pv&amp;#95;porcupine&amp;#95;object&amp;#95;t&amp;#42;&amp;#41;handle, pcm, &amp;amp;result&amp;#41;;

  &amp;#40;&amp;#42;env&amp;#41;-&amp;gt;ReleaseShortArrayElements&amp;#40;env, pcm&amp;#95;raw, pcm, 0&amp;#41;;

  return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let's modify the &lt;code&gt;Makefile&lt;/code&gt; to compile our C and Java code:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;makefile&quot;&gt;WAKE&amp;#95;PHRASE := hey porcupine

wake-word-engine: wake-word-engine/Porcupine wake-word-engine/wake&amp;#95;phrase.ppn wake-word-engine/jni/libpv&amp;#95;porcupine.so src/java/wakeup/porcupine/Porcupine.class

# ------- 8&amp;lt; -------

src/java/wakeup/porcupine/Porcupine.class wake-word-engine/jni/wakeup&amp;#95;porcupine&amp;#95;Porcupine.h: src/java/wakeup/porcupine/Porcupine.java
	mkdir -p wake-word-engine/jni
	javac -h wake-word-engine/jni src/java/wakeup/porcupine/Porcupine.java

wake-word-engine/jni/libpv&amp;#95;porcupine.so: wake-word-engine/jni/wakeup&amp;#95;porcupine&amp;#95;Porcupine.h src/c/porcupine.c
	gcc -shared -O3 \
		-I/usr/include \
		-I/usr/lib/jvm/default/include \
		-I/usr/lib/jvm/default/include/linux \
		-Iwake-word-engine/Porcupine/include \
		-Iwake-word-engine/jni \
		src/c/porcupine.c \
		wake-word-engine/Porcupine/lib/linux/x86&amp;#95;64/libpv&amp;#95;porcupine.a \
		-o wake-word-engine/jni/libpv&amp;#95;porcupine.so
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So the default &lt;code&gt;make&lt;/code&gt; command, &lt;code&gt;wake-word-engine&lt;/code&gt;, now depends upon Porcupine, the &lt;code&gt;.ppn&lt;/code&gt; file, C compiled to a &lt;code&gt;.so&lt;/code&gt; and Java compiled to a &lt;code&gt;.class&lt;/code&gt;. We can now write some Clojure that imports &lt;code&gt;&amp;#91;wakeup.porcupine Porcupine&amp;#93;&lt;/code&gt; and runs some audio through it.&lt;/p&gt;&lt;h2 id=&quot;using&amp;#95;the&amp;#95;binding&quot;&gt;Using the binding&lt;/h2&gt;&lt;p&gt;I've written a Clojure namespace that grabs your microphone as input and streams it through the Porcupine binding, logging whenever it hears the wake phrase. I think this should be more than enough to get most people going with their own voice activated programs.&lt;/p&gt;&lt;p&gt;Place this in &lt;code&gt;src/clojure/wakeup/main.clj&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns wakeup.main
  &amp;#40;:import &amp;#91;wakeup.porcupine Porcupine&amp;#93;

           ;; These are required for the microphone input.
           &amp;#91;javax.sound.sampled AudioFormat DataLine TargetDataLine AudioSystem&amp;#93;&amp;#41;&amp;#41;

;; Notes on audio formats:
;; Discord provides audio as `48KHz 16bit stereo signed BigEndian PCM`.
;; Porcupine requires `16KHz 16bit mono signed LittleEndian PCM` but in 512 length short-array frames &amp;#40;a short is two bytes&amp;#41;.
;; GCP speech recognition requires the same as Porcupine but as byte pairs and without the 512 frames.

&amp;#40;defn init-porcupine &amp;#91;&amp;#93;
  &amp;#40;Porcupine. &amp;quot;wake-word-engine/Porcupine/lib/common/porcupine&amp;#95;params.pv&amp;quot;
              &amp;quot;wake-word-engine/wake&amp;#95;phrase.ppn&amp;quot;
              0.5&amp;#41;&amp;#41;

;; Adapted from: https://gist.github.com/BurkeB/ebf5f01c0d20ff6b9dc111ac427ddea8
&amp;#40;defn with-microphone &amp;#91;f&amp;#93;
  &amp;#40;let &amp;#91;audio-format &amp;#40;new AudioFormat 16000 16 1 true true&amp;#41;
        info &amp;#40;new javax.sound.sampled.DataLine$Info TargetDataLine audio-format&amp;#41;&amp;#93;

    &amp;#40;when-not &amp;#40;AudioSystem/isLineSupported info&amp;#41;
      &amp;#40;throw &amp;#40;Error. &amp;quot;AudioSystem/isLineSupported returned false&amp;quot;&amp;#41;&amp;#41;&amp;#41;

    &amp;#40;with-open &amp;#91;line &amp;#40;AudioSystem/getTargetDataLine audio-format&amp;#41;&amp;#93;
      &amp;#40;doto line
        &amp;#40;.open audio-format&amp;#41;
        &amp;#40;.start&amp;#41;&amp;#41;

      &amp;#40;f line&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn byte-pair-&amp;gt;short &amp;#91;&amp;#91;a b&amp;#93;&amp;#93;
  &amp;#40;bit-or &amp;#40;bit-shift-left a 8&amp;#41; &amp;#40;bit-and b 0xFF&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn bytes-&amp;gt;shorts &amp;#91;buf&amp;#93;
  &amp;#40;-&amp;gt;&amp;gt; buf
       &amp;#40;partition 2&amp;#41;
       &amp;#40;map byte-pair-&amp;gt;short&amp;#41;
       &amp;#40;short-array&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn -main &amp;#91;&amp;#93;
  &amp;#40;println &amp;quot;Starting up wake word detector...&amp;quot;&amp;#41;
  &amp;#40;let &amp;#91;porcupine &amp;#40;init-porcupine&amp;#41;&amp;#93;
    &amp;#40;with-microphone
      &amp;#40;fn &amp;#91;line&amp;#93;
        &amp;#40;let &amp;#91;size 1024
              buf &amp;#40;byte-array size&amp;#41;&amp;#93;
          &amp;#40;println &amp;quot;Listening...&amp;quot;&amp;#41;
          &amp;#40;loop &amp;#91;&amp;#93;
            &amp;#40;when &amp;#40;&amp;gt; &amp;#40;.read line buf 0 size&amp;#41; 0&amp;#41;
              &amp;#40;when &amp;#40;.processFrame porcupine &amp;#40;bytes-&amp;gt;shorts buf&amp;#41;&amp;#41;
                &amp;#40;println &amp;quot;Wake word detected!&amp;quot;&amp;#41;&amp;#41;
              &amp;#40;recur&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now create a &lt;code&gt;deps.edn&lt;/code&gt; for the &lt;a href='https://clojure.org/guides/deps_and_cli'&gt;Clojure CLI&lt;/a&gt; (if you haven't already):&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;edn&quot;&gt;{:paths &amp;#91;&amp;quot;src/clojure&amp;quot; &amp;quot;src/java&amp;quot;&amp;#93;
 :deps {org.clojure/clojure {:mvn/version &amp;quot;1.9.0&amp;quot;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And finally add a line to start our application as the first entry in our makefile:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;makefile&quot;&gt;default: wake-word-engine
	LD&amp;#95;LIBRARY&amp;#95;PATH=&amp;quot;wake-word-engine/jni&amp;quot; clojure -m wakeup.main
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, we need to specify the &lt;code&gt;LD&amp;#95;LIBRARY&amp;#95;PATH&lt;/code&gt; for our binding which I think varies depending on your operating system. This works for Linux but I think the name is slightly different for OSX, I'm afraid I have no idea how it would work on Windows.&lt;/p&gt;&lt;p&gt;When I execute &lt;code&gt;make&lt;/code&gt; I can then say &quot;hey porcupine&quot; to my laptop and get this output:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ make
LD&amp;#95;LIBRARY&amp;#95;PATH=&amp;quot;wake-word-engine/jni&amp;quot; clojure -m wakeup.main
Starting up wake word detector...
Listening...
Wake word detected!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I hope this has been helpful and allows you to build voice activated programs of your own.&lt;/p&gt;
</description>
<pubDate>
Fri, 12 Oct 2018 00:00:00 +0100
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2018-05-04-editing-clojure-with-neovim/
</guid>
<link>
https://oli.me.uk/2018-05-04-editing-clojure-with-neovim/
</link>
<title>
Editing Clojure with Neovim
</title>
<description>
&lt;p&gt;I've used &lt;a href='http://spacemacs.org/'&gt;Spacemacs&lt;/a&gt; since I started working with &lt;a href='https://clojure.org/'&gt;Clojure&lt;/a&gt; a few years ago, it's an extremely powerful system on par with full IDEs such as &lt;a href='https://cursive-ide.com/'&gt;Cursive&lt;/a&gt;. I highly recommend either of these tools to the budding Clojure(Script) developer, they will carry you as far as you need to go and beyond.&lt;/p&gt;&lt;p&gt;The reason I have drifted back to &lt;a href='https://www.vim.org/'&gt;Vim&lt;/a&gt; (&lt;a href='https://neovim.io/'&gt;Neovim&lt;/a&gt; specifically) is because I never felt quite at home within &lt;a href='https://www.gnu.org/software/emacs/'&gt;Emacs&lt;/a&gt;, which Spacemacs is built upon. I wrote JavaScript (among other languages) in Vim for around five years before I began really studying Clojure. Vim and it's nuances are pretty deeply buried within my brain and muscle memory (if that's actually a thing).&lt;/p&gt;&lt;p&gt;I've been working on a fresh Neovim setup in my &lt;a href='https://github.com/Olical/dotfiles'&gt;dotfiles&lt;/a&gt; repository and I'm finally at a point where I'm happy with it for day to day work. I extracted my current setup into &lt;a href='https://github.com/Olical/spacy-neovim'&gt;spacy-neovim&lt;/a&gt; for others to fork and build upon in their own repositories. It acts as an opinionated starting point modeled after Spacemacs that you're expected to modify to fit your needs.&lt;/p&gt;&lt;p&gt;This post will mainly be describing the approach I'm taking in my dotfiles and the spacy-neovim repository.&lt;/p&gt;&lt;h2 id=&quot;structure&quot;&gt;Structure&lt;/h2&gt;&lt;p&gt;The layout of my configuration is almost identical to my previous JavaScript setup:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;There's a top level entry point: &lt;code&gt;init.vim&lt;/code&gt;, it sources every file in the &lt;code&gt;modules/&lt;/code&gt; directory.&lt;/li&gt;&lt;li&gt;A file in the root directory, &lt;code&gt;plugins.vim&lt;/code&gt;, simply lists all of my dependencies for &lt;a href='https://github.com/junegunn/vim-plug'&gt;vim-plug&lt;/a&gt; to handle.&lt;/li&gt;&lt;li&gt;The &lt;code&gt;modules/&lt;/code&gt; directory contains different configuration related files.&lt;ul&gt;&lt;li&gt;&lt;code&gt;modules/core.vim&lt;/code&gt; - Super basic and general configuration for the entire editor.&lt;/li&gt;&lt;li&gt;&lt;code&gt;modules/mappings.vim&lt;/code&gt; - Custom mappings for things like closing hidden buffers or trimming whitespace.&lt;/li&gt;&lt;li&gt;&lt;code&gt;modules/plugins.vim&lt;/code&gt; - Activates vim-plug and loads configuration files for those plugins. It also warns you if you've remove a plugin but not the configuration file on startup.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Plugin configuration files are found in &lt;code&gt;modules/plugins/&lt;/code&gt;, like &lt;code&gt;modules/plugins/vim-fireplace.vim&lt;/code&gt;. They set plugins up and define useful bindings to access their functionality.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Speaking of which, let's have a tour of some of the most important plugins that are included.&lt;/p&gt;&lt;h2 id=&quot;plugins&quot;&gt;Plugins&lt;/h2&gt;&lt;h3 id=&quot;&lt;a href='https://github.com/tpope/vim-fireplace'&gt;tpope/vim-fireplace&lt;/a&gt;&quot;&gt;&lt;a href='https://github.com/tpope/vim-fireplace'&gt;tpope/vim-fireplace&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;This is essential. If you wish to edit Clojure within Vim you'll need this plugin above all others, it gives you a way to interact with and evaluate your Clojure code via an &lt;a href='https://github.com/clojure-emacs/cider-nrepl'&gt;nREPL&lt;/a&gt; connection.&lt;/p&gt;&lt;p&gt;I've defined the following bindings in &lt;code&gt;modules/plugins/vim-fireplace.vim&lt;/code&gt;, they make using it feel a little more like &lt;a href='https://github.com/clojure-emacs/cider'&gt;CIDER&lt;/a&gt; (The Clojure Interactive Development Environment that Rocks for Emacs).&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;viml&quot;&gt;autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;re :Eval&amp;lt;cr&amp;gt;
autocmd FileType clojure vnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;re :Eval&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;rf :%Eval&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;rr :Require&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;rR :Require!&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;rt :RunTests&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;rl :Last&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;localleader&amp;gt;rc :FireplaceConnect&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; gd :normal &amp;#91;&amp;lt;c-d&amp;gt;&amp;lt;cr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;My &lt;code&gt;localleader&lt;/code&gt; is set to &lt;code&gt;,&lt;/code&gt; so I usually hit &lt;code&gt;,rc&lt;/code&gt; to connect to a REPL then a mixture of &lt;code&gt;cpp&lt;/code&gt; to evaluate the innermost form and &lt;code&gt;,re&lt;/code&gt; to evaluate the outermost.&lt;/p&gt;&lt;p&gt;I encountered some features I missed from CIDER, namely being able to reload every namespace and reboot the system with a single binding. I also created some bindings to automatically connect to my API and UI REPLs at work, I have this &lt;code&gt;.lvimrc&lt;/code&gt; defined within my work repo.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;viml&quot;&gt;autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; &amp;lt;localleader&amp;gt;rA :FireplaceConnect nrepl://localhost:9001 %{getcwd&amp;#40;&amp;#41;}&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; &amp;lt;localleader&amp;gt;rU :FireplaceConnect nrepl://localhost:9002 %{getcwd&amp;#40;&amp;#41;}&amp;lt;cr&amp;gt;:e dev/user.clj&amp;lt;cr&amp;gt;:Eval &amp;#40;cljs-repl&amp;#41;&amp;lt;cr&amp;gt;:bd&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; &amp;lt;localleader&amp;gt;rx :Eval &amp;#40;do &amp;#40;require 'clojure.tools.namespace.repl&amp;#41; &amp;#40;bounce.system/stop!&amp;#41; &amp;#40;clojure.tools.namespace.repl/set-refresh-dirs &amp;quot;src/clj&amp;quot; &amp;quot;src/cljc&amp;quot;&amp;#41; &amp;#40;clojure.tools.namespace.repl/refresh :after 'bounce.system/start!&amp;#41;&amp;#41;&amp;lt;cr&amp;gt;
autocmd FileType clojure nnoremap &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; &amp;lt;localleader&amp;gt;rX :Eval &amp;#40;do &amp;#40;require 'clojure.tools.namespace.repl&amp;#41; &amp;#40;bounce.system/stop!&amp;#41; &amp;#40;clojure.tools.namespace.repl/clear&amp;#41; &amp;#40;clojure.tools.namespace.repl/set-refresh-dirs &amp;quot;src/clj&amp;quot; &amp;quot;src/cljc&amp;quot;&amp;#41; &amp;#40;clojure.tools.namespace.repl/refresh-all :after 'bounce.system/start!&amp;#41;&amp;#41;&amp;lt;cr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;,rA&lt;/code&gt; connects me to my API REPL.&lt;/li&gt;&lt;li&gt;&lt;code&gt;,rU&lt;/code&gt; connects me to the UI REPL and evaluates the figwheel piggieback code to hook it up to my browser.&lt;/li&gt;&lt;li&gt;&lt;code&gt;,rx&lt;/code&gt; shuts the system down, reloads changed namespaces and starts it back up.&lt;/li&gt;&lt;li&gt;&lt;code&gt;,rX&lt;/code&gt; shuts the system down, reloads &lt;i&gt;every&lt;/i&gt; namespace and starts it back up.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Once I have my API or UI REPL connection up all evaluation and autocompletion works for the given context, so that'll either be Clojure or ClojureScript. I can only have one connection at a time, but that connection works really damn well.&lt;/p&gt;&lt;h3 id=&quot;&lt;a href='https://github.com/guns/vim-sexp'&gt;guns/vim-sexp&lt;/a&gt;&quot;&gt;&lt;a href='https://github.com/guns/vim-sexp'&gt;guns/vim-sexp&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;a href='https://github.com/easymotion/vim-easymotion'&gt;EasyMotion&lt;/a&gt; is still my favourite way to navigate but vim-sexp is my favourite way to edit. I use it in place of &lt;a href='https://github.com/sp3ctum/evil-lispy'&gt;evil-lispy&lt;/a&gt; in Emacs to manipulate s-expressions.&lt;/p&gt;&lt;p&gt;The default bindings involve holding down a few modifiers like &lt;code&gt;ctrl&lt;/code&gt; and &lt;code&gt;alt&lt;/code&gt; and pressing a mixture of &lt;code&gt;hjkl&lt;/code&gt; keys which I actually quite like. I still have &lt;a href='https://github.com/tpope/vim-sexp-mappings-for-regular-people'&gt;vim-sexp-mappings-for-regular-people&lt;/a&gt; installed but I've found myself using it less and less as I learn the extensive bindings of vim-sexp.&lt;/p&gt;&lt;p&gt;Maybe my slightly esoteric custom ErgoDox keyboard layout makes that easier than the bindings are on a regular keyboard. Luckily tpope's enhancement plugin provides more than a couple of simple rebindings so I'd highly recommend you use it even if you don't mind the meta key shenanigans.&lt;/p&gt;&lt;h3 id=&quot;so&amp;#95;many&amp;#95;more&quot;&gt;So many more&lt;/h3&gt;&lt;p&gt;The best way to explore this setup is to skim the README in &lt;a href='https://github.com/Olical/spacy-neovim'&gt;spacy-neovim&lt;/a&gt; as well as browse the source (which is pretty short). I list a few more of the features and link to their configuration source in the repository, you may find that useful.&lt;/p&gt;&lt;h2 id=&quot;:wq&quot;&gt;:wq&lt;/h2&gt;&lt;p&gt;I hope this repository helps you to get started with your own Neovim and Clojure editor setup. If you've tried Cursive and Spacemacs but decided it's not for you and you need to return to Vim I'm here to tell you that's it's totally possible.&lt;/p&gt;&lt;p&gt;Use what I've made as a starting point to get a bunch of low hanging fruit out of the way then customise your editor to your needs.&lt;/p&gt;&lt;p&gt;Feel free to reach out to me in the comments or on twitter (&lt;a href='https://twitter.com/OliverCaldwell'&gt;@OliverCaldwell&lt;/a&gt;) if you have any questions or insights for me.&lt;/p&gt;
</description>
<pubDate>
Fri, 04 May 2018 00:00:00 +0100
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2018-03-29-finding-new-dependencies-with-depot/
</guid>
<link>
https://oli.me.uk/2018-03-29-finding-new-dependencies-with-depot/
</link>
<title>
Finding new dependencies with Depot
</title>
<description>
&lt;p&gt;If you're using lein you can use lein-ancient to find newer versions of your dependencies, if you're using boot you probably have something similar. With the Clojure CLI however you have to keep track of these things manually.&lt;/p&gt;&lt;p&gt;I've created a little tool called &lt;a href='https://github.com/Olical/depot'&gt;Depot&lt;/a&gt; that aims to give you this same new version detection for your &lt;code&gt;deps.edn&lt;/code&gt; file. The README is probably enough to get you going but here's a little example anyway.&lt;/p&gt;&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;&lt;p&gt;You'll want to add Depot to your &lt;code&gt;deps.edn&lt;/code&gt; file, you can do this at the project level or within your user-wide file at &lt;code&gt;&amp;#126;/.clojure/deps.edn&lt;/code&gt;. I'd recommend you add it at a project level however since this'll allow anyone working on your codebase to use the same tooling, especially if it's wrapped up in a &lt;code&gt;Makefile&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:deps {org.clojure/clojure {:mvn/version &amp;quot;1.9.0&amp;quot;}
        org.clojure/clojurescript {:mvn/version &amp;quot;1.10.238&amp;quot;}}
 :aliases {:outdated {:extra-deps {olical/depot {:mvn/version &amp;quot;1.0.1&amp;quot;}}
                      :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;depot.outdated.main&amp;quot;&amp;#93;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now execute Depot by referring to our alias:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clojure -Aoutdated
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At the time of writing this doesn't output anything since everything's up to date. If we were to depend on, say, ClojureScript 1.9.946 however:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clojure -Aoutdated
org.clojure/clojurescript: 1.9.946 =&amp;gt; 1.10.238
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we're also depending on Depot 1.0.0, as opposed to the currently released 1.0.1, we could even have it check it's own alias:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clojure -Aoutdated --aliases outdated
org.clojure/clojurescript: 1.9.946 =&amp;gt; 1.10.238
olical/depot: 1.0.0 =&amp;gt; 1.0.1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can also ask it to consider non-release versions such as snapshots and qualified versions such as alphas. This will pick the very latest version, regardless of stability:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clojure -Aoutdated --aliases outdated --consider-types qualified,release,snapshot
org.clojure/clojure: 1.9.0 =&amp;gt; 1.10.0-alpha4
org.clojure/clojurescript: 1.9.946 =&amp;gt; 1.10.238
olical/depot: 1.0.0 =&amp;gt; 1.0.1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I hope you find Depot useful in keeping your dependencies up to date.&lt;/p&gt;
</description>
<pubDate>
Thu, 29 Mar 2018 00:00:00 +0100
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2018-03-29-clojure-and-clojurescript-tests-on-travis/
</guid>
<link>
https://oli.me.uk/2018-03-29-clojure-and-clojurescript-tests-on-travis/
</link>
<title>
Clojure and ClojureScript tests on Travis
</title>
<description>
&lt;p&gt;As far as I can tell, there isn't a canonical way to run your Clojure(Script) tests on &lt;a href='http://travis-ci.org/'&gt;Travis&lt;/a&gt; through the Clojure CLI. I think it's slightly easier for those of you using &lt;code&gt;lein&lt;/code&gt;, but here's how to do it with &lt;code&gt;clj&lt;/code&gt;.&lt;/p&gt;&lt;h2 id=&quot;dependencies&quot;&gt;Dependencies&lt;/h2&gt;&lt;p&gt;You'll need a couple of deps to execute your tests, here's an example &lt;code&gt;deps.edn&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:deps {org.clojure/clojure {:mvn/version &amp;quot;1.9.0&amp;quot;}
        org.clojure/clojurescript {:mvn/version &amp;quot;1.10.238&amp;quot;} }
 :aliases {:test-clj {:extra-paths &amp;#91;&amp;quot;test&amp;quot;&amp;#93;
                      :extra-deps {com.cognitect/test-runner {:git/url &amp;quot;https://github.com/Olical/test-runner.git&amp;quot;
                                                              :sha &amp;quot;7c4f5bd4987ec514889c7cd7e3d13f4ef95f256b&amp;quot;}}
                      :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;cognitect.test-runner&amp;quot;&amp;#93;}
           :test-cljs {:extra-deps {olical/cljs-test-runner {:mvn/version &amp;quot;0.1.1&amp;quot;}}
                       :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;cljs-test-runner.main&amp;quot;&amp;#93;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This pulls down my patched version of the cognitect test-runner and my ClojureScript (loose) clone of the same library. The current cognitect test-runner doesn't report non-zero exit statuses when tests fail, my patch adds them, I'm hoping to get it merged in some form or another soon.&lt;/p&gt;&lt;p&gt;Without the exit status patch Travis won't know that your tests actually failed.&lt;/p&gt;&lt;h2 id=&quot;convenience&quot;&gt;Convenience&lt;/h2&gt;&lt;p&gt;Here's a &lt;code&gt;Makefile&lt;/code&gt; that wraps up the test commands, it makes it a little easier to call:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;Makefile&quot;&gt;.PHONY: test test-clj test-cljs

test: test-clj test-cljs

test-clj:
	clojure -Atest-clj

test-cljs:
	clojure -Atest-cljs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is obviously optional, feel free to avoid it if you want to.&lt;/p&gt;&lt;h2 id=&quot;travis&amp;#95;configuration&quot;&gt;Travis configuration&lt;/h2&gt;&lt;p&gt;Now we have some tools to test our code, let's configure Travis to execute them with your &lt;code&gt;.travis.yml&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;yaml&quot;&gt;sudo: true
language: java
script: make test
install:
  - curl -O https://download.clojure.org/install/linux-install-1.9.0.358.sh
  - chmod +x linux-install-1.9.0.358.sh
  - sudo ./linux-install-1.9.0.358.sh
jdk:
  - oraclejdk8
cache:
  directories:
    - $HOME/.m2
    - $HOME/.cljs
    - $HOME/.gitlibs
    - node&amp;#95;modules
    - .cpcache
    - cljs-test-runner-out
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This configuration will set up the Clojure CLI, cache all of the appropriate directories and run your test suites. Feel free to take parts of this that you find useful and ignore others.&lt;/p&gt;&lt;p&gt;You should now connect your repo to your Travis account, it will report to you whenever your tests start failing. Enjoy!&lt;/p&gt;
</description>
<pubDate>
Thu, 29 Mar 2018 00:00:00 +0100
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2018-03-09-clojure-and-clojurescript-testing-with-the-clojure-cli/
</guid>
<link>
https://oli.me.uk/2018-03-09-clojure-and-clojurescript-testing-with-the-clojure-cli/
</link>
<title>
Clojure and ClojureScript testing with the Clojure CLI
</title>
<description>
&lt;p&gt;This post is sort of an extension of a previous post, &lt;a href='https://oli.me.uk/2018-02-26-clojure-projects-from-scratch/'&gt;Clojure projects from scratch&lt;/a&gt;. That will introduce you to structuring your project around a &lt;code&gt;deps.edn&lt;/code&gt; file, here we're going to simply add a couple of dependencies that allow you to run your tests.&lt;/p&gt;&lt;p&gt;In a &lt;a href='https://leiningen.org/'&gt;Leiningen&lt;/a&gt; project, &lt;code&gt;lein test&lt;/code&gt; will execute your Clojure tests, no questions asked. In a Clojure CLI / &lt;code&gt;deps.edn&lt;/code&gt; based project we have no such command, tests have to be executed by a custom built test runner script.&lt;/p&gt;&lt;p&gt;You probably don't want to be writing and modifying a test runner namespace every time you add a test, that's why &lt;a href='https://github.com/cognitect-labs/test-runner'&gt;test-runner&lt;/a&gt; and &lt;a href='https://github.com/Olical/cljs-test-runner'&gt;cljs-test-runner&lt;/a&gt; exist. I'm the author of the latter, I hope that doesn't put you off.&lt;/p&gt;&lt;h2 id=&quot;test-runner&quot;&gt;test-runner&lt;/h2&gt;&lt;p&gt;First we'll add test-runner, the Clojure version. This will give us an equivalent to &lt;code&gt;lein test&lt;/code&gt;. Add a &lt;code&gt;test&lt;/code&gt; alias to your &lt;code&gt;aliases&lt;/code&gt; section of your &lt;code&gt;deps.edn&lt;/code&gt; file.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:deps ;; 1
 {org.clojure/clojure {:mvn/version &amp;quot;1.9.0&amp;quot;}
  org.clojure/clojurescript {:mvn/version &amp;quot;1.10.145&amp;quot;}}

 :aliases
 {:test ;; 2
  {:extra-paths &amp;#91;&amp;quot;test&amp;quot;&amp;#93; ;; 3
   :extra-deps
   {com.cognitect/test-runner {:git/url &amp;quot;git@github.com:cognitect-labs/test-runner&amp;quot;
                               :sha &amp;quot;76568540e7f40268ad2b646110f237a60295fa3c&amp;quot;}} ;; 4
   :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;cognitect.test-runner&amp;quot;&amp;#93;}}} ;; 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let's break this down a little, just in case you aren't super familiar with &lt;code&gt;deps.edn&lt;/code&gt; just yet.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Map of your dependencies, here we're depending on the latest Clojure and ClojureScript. Having your language as a versioned dependency is a wonderful thing.&lt;/li&gt;&lt;li&gt;Our test alias, we'll activate it with &lt;code&gt;clojure -Atest&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;For Clojure tests, we need to add the test directory to the classpath.&lt;/li&gt;&lt;li&gt;Dependency on the test-runner, there may be a new commit by now. I'm waiting for my &lt;a href='https://github.com/cognitect-labs/test-runner/pull/12'&gt;return code fix&lt;/a&gt; to be merged.&lt;/li&gt;&lt;li&gt;Set the entry namespace to the test runner.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;We can now execute our tests as we would with &lt;code&gt;lein&lt;/code&gt;!&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clojure -Atest
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At the time of writing, even if your tests fail, the return code of the process will always be 0. This means that your CLI and CI will think the tests passed just fine. I've fixed this and it may have been merged by the time you're reading this. If not, feel free to use the fixed commit from my fork.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:git/url &amp;quot;git@github.com:Olical/test-runner.git&amp;quot;
 :sha &amp;quot;7c4f5bd4987ec514889c7cd7e3d13f4ef95f256b&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;cljs-test-runner&quot;&gt;cljs-test-runner&lt;/h2&gt;&lt;p&gt;Running ClojureScript tests is usually a bit of a pain. You've got to work out how to get it compiling then have that plugged into a test runner such as &lt;a href='https://github.com/bensu/doo'&gt;doo&lt;/a&gt;. This doesn't account for test file discovery, so you've still got to specify each of your test namespaces manually.&lt;/p&gt;&lt;p&gt;I've wrapped up doo with a few namespace tools and the ClojureScript compiler to give you a single command that handles all of this for you. Let's add another alias containing cljs-test-runner. You may want to check for new versions since it may have changed since I wrote this.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:test-cljs
{:extra-deps
 {olical/cljs-test-runner {:mvn/version &amp;quot;0.1.1&amp;quot;}}
 :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;cljs-test-runner.main&amp;quot;&amp;#93;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see it's extremely similar to the Clojure test-runner setup, one difference is that we don't need to add our test directory to the classpath. ClojureScript doesn't rely on the classpath, instead there is a flag that you can set if your tests are somewhere other than the default test directory.&lt;/p&gt;&lt;p&gt;You can execute your tests with the following command, it'll run them in node by default. You can change the environment to phantom if required, this may have changed since writing.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clojure -Atest-cljs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If everything went according to plan it should have found your &lt;code&gt;.cljs&lt;/code&gt; and &lt;code&gt;.cljc&lt;/code&gt; test namespaces, compiled them and executed them through node. If it didn't, I'm sure you can work it out, or raise an issue if you think there's a problem.&lt;/p&gt;&lt;h2 id=&quot;running&amp;#95;both&quot;&gt;Running both&lt;/h2&gt;&lt;p&gt;You'll now be able to run your Clojure and ClojureScript tests side by side, hassle free, locally or through CI.&lt;/p&gt;&lt;p&gt;Bear in mind that the Clojure test-runner will always return a good exit status, even when the tests fail at the time of writing. Make sure my fix has been merged or use my fork if you need the correct exit status.&lt;/p&gt;
</description>
<pubDate>
Fri, 09 Mar 2018 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2018-03-04-clojure-and-clojurescript-nrepl-with-clojure-cli/
</guid>
<link>
https://oli.me.uk/2018-03-04-clojure-and-clojurescript-nrepl-with-clojure-cli/
</link>
<title>
Clojure and ClojureScript nREPL with Clojure CLI
</title>
<description>
&lt;p&gt;If you've decided to try out the new Clojure CLI introduced with Clojure 1.9 you may have found yourself slightly lost when it comes to getting your CIDER (or other development environment) hooked up to your project through nREPL. My previous post, &lt;a href='https://oli.me.uk/2018-02-26-clojure-projects-from-scratch/'&gt;Clojure projects from scratch&lt;/a&gt;, may help you with understanding these concepts and tools if you're struggling to get going.&lt;/p&gt;&lt;p&gt;In this post I'm going to show you a few simple steps you need to take to get your nREPL running smoothly. I am hosting the ClojureScript nREPL through NodeJS, you can probably adjust the configuration if you need it to run in something else.&lt;/p&gt;&lt;h2 id=&quot;the&amp;#95;deps&quot;&gt;The deps&lt;/h2&gt;&lt;p&gt;We're going to be using the following tools:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://github.com/clojure/tools.nrepl'&gt;clojure/tools.nrepl&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/clojure-emacs/cider-nrepl'&gt;clojure-emacs/cider-nrepl&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/cemerick/piggieback'&gt;cemerick/piggieback&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Here's the &lt;code&gt;deps.edn&lt;/code&gt; file we're going to want. This is the minimal required amount, so you'll need to integrate all of this into your own &lt;code&gt;deps.edn&lt;/code&gt;. The Clojure and ClojreScript versions may vary.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:deps
 {org.clojure/clojure {:mvn/version &amp;quot;1.9.0&amp;quot;}
  org.clojure/clojurescript {:mvn/version &amp;quot;1.10.64&amp;quot;}}

 :aliases
 {:nrepl-server
  {:extra-paths &amp;#91;&amp;quot;dev&amp;quot;&amp;#93;
   :extra-deps
   {com.cemerick/piggieback {:mvn/version &amp;quot;0.2.2&amp;quot;}
    org.clojure/tools.nrepl {:mvn/version &amp;quot;0.2.12&amp;quot;}
    cider/cider-nrepl {:mvn/version &amp;quot;0.17.0-SNAPSHOT&amp;quot;}}
   :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;nrepl-server&amp;quot;&amp;#93;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You may want to add a small Makefile to make executing with this alias a little smoother:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;Makefile&quot;&gt;.PHONY: nrepl-server

nrepl-server:
	clj -Anrepl-server
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;the&amp;#95;namespaces&quot;&gt;The namespaces&lt;/h2&gt;&lt;p&gt;You may have noticed my reference to the &lt;code&gt;nrepl-server&lt;/code&gt; namespace and &lt;code&gt;dev&lt;/code&gt; directory in the &lt;code&gt;deps.edn&lt;/code&gt; file, we need to create these before our nREPL server will work.&lt;/p&gt;&lt;p&gt;Add the following files to your project:&lt;/p&gt;&lt;h3 id=&quot;dev/nrepl&amp;#95;server.clj&quot;&gt;dev/nrepl&amp;#95;server.clj&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns nrepl-server
  &amp;#40;:require &amp;#91;cider-nrepl.main :as nrepl&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn -main &amp;#91;&amp;#93;
  &amp;#40;nrepl/init &amp;#91;&amp;quot;cider.nrepl/cider-middleware&amp;quot;
               &amp;quot;cemerick.piggieback/wrap-cljs-repl&amp;quot;&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;dev/user.clj&quot;&gt;dev/user.clj&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns user
  &amp;#40;:require &amp;#91;cemerick.piggieback :as piggieback&amp;#93;
            &amp;#91;cljs.repl.node :as node-repl&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn cljs-repl &amp;#91;&amp;#93;
  &amp;#40;piggieback/cljs-repl &amp;#40;node-repl/repl-env&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These files will allow us to firstly boot our nREPL server with the correct middleware and secondly allow us to easily drop into a ClojureScript REPL.&lt;/p&gt;&lt;h2 id=&quot;getting&amp;#95;connected&quot;&gt;Getting connected&lt;/h2&gt;&lt;p&gt;If you added a rule to your &lt;code&gt;Makefile&lt;/code&gt;, you can use &lt;code&gt;make nrepl-server&lt;/code&gt;, alternatively just type &lt;code&gt;clj -Anrepl-server&lt;/code&gt;. You should see something like this:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ make nrepl-server
clj -Anrepl-server
nREPL server started on port 40047 on host localhost - nrepl://localhost:40047
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Your bindings may vary, but in &lt;a href='http://spacemacs.org/'&gt;Spacemacs&lt;/a&gt; I would type &lt;code&gt;,sc&lt;/code&gt; and then just hit enter twice to select &lt;code&gt;localhost&lt;/code&gt; and the currently running server. CIDER knows the server port because it should've created a &lt;code&gt;.nrepl-port&lt;/code&gt; file in your current directory.&lt;/p&gt;&lt;p&gt;Once you're connected, you can start evaluating Clojure code, how wonderful! When you wish to drop into a ClojureScript REPL backed by NodeJS (by default), you can use the &lt;code&gt;cljs-repl&lt;/code&gt; function we defined in your &lt;code&gt;user&lt;/code&gt; namespace. Just open the REPL (&lt;code&gt;,ss&lt;/code&gt; in Spacemacs) and execute &lt;code&gt;&amp;#40;cljs-repl&amp;#41;&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;If everything went according to plan, you should now be able to evaluate ClojureScript code as easy as Clojure. If you are jumping between Clojure and ClojureScript namespaces, you'll have to connect twice with one of those REPLs in ClojureScript mode.&lt;/p&gt;&lt;p&gt;A REPL can only ever be serving Clojure or ClojureScript, not both at the same time. Once you execute &lt;code&gt;&amp;#40;cljs-repl&amp;#41;&lt;/code&gt; that connection becomes ClojureScript specific.&lt;/p&gt;
</description>
<pubDate>
Sun, 04 Mar 2018 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2018-02-26-clojure-projects-from-scratch/
</guid>
<link>
https://oli.me.uk/2018-02-26-clojure-projects-from-scratch/
</link>
<title>
Clojure projects from scratch
</title>
<description>
&lt;p&gt;This post is intended &lt;i&gt;primarily&lt;/i&gt; for two groups of people:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;People just starting out in Clojure, who know parts of the language but don't know how to begin structuring a real project.&lt;/li&gt;&lt;li&gt;Seasoned Clojurians who wish to see how to structure a project with the new Clojure CLI + &lt;code&gt;deps.edn&lt;/code&gt; and not &lt;a href='https://leiningen.org/'&gt;lein&lt;/a&gt; or &lt;a href='http://boot-clj.com/'&gt;boot&lt;/a&gt; (even though they're still awesome).&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;My goal is to teach you how to go from an empty directory, to a project you can run, test, compile and (if you wish to) publish with ease. We're going to get there through a series of relatively small steps so you can understand all the tools you're using.&lt;/p&gt;&lt;p&gt;There won't be an awful lot of Clojure code here, so don't worry if you're still getting your head around the language itself. The only code example will be a &quot;Hello, World!&quot;, if that helps.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; Note: This post assumes usage of Linux, OSX or similar, I'm afraid it isn't intended for Windows users since I just don't have the knowledge to help you there. Some of the information will apply, but you'll have to adapt things, I'm sure you can find Windows specific guides for the parts that don't fit. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;I'm not going into what editor you should use because that's a book in itself. If you're totally at a loss, check out &lt;a href='https://cursive-ide.com/'&gt;Cursive&lt;/a&gt;, although I use &lt;a href='http://spacemacs.org/'&gt;Spacemacs&lt;/a&gt; because I can't survive without good Vim emulation. There's probably a great plugin for your editor of choice and instructions on getting started, have a Google.&lt;/p&gt;&lt;p&gt;A lot of what I'm going to be talking about can be found in practice in &lt;a href='https://github.com/robert-stuttaford/bridge'&gt;github.com/robert-stuttaford/bridge&lt;/a&gt;, you may want to have a peruse at some point.&lt;/p&gt;&lt;h2 id=&quot;installing&amp;#95;the&amp;#95;clojure&amp;#95;cli&quot;&gt;Installing the Clojure CLI&lt;/h2&gt;&lt;p&gt;To run Clojure you'll need the command line tool (introduced around the time of Clojure 1.9) that manages dependencies and allows you execute code.&lt;/p&gt;&lt;p&gt;If you're on OSX, you can use &lt;code&gt;brew&lt;/code&gt; to install the CLI.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ brew install clojure
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I have found that I could install it through the Arch Linux package manager although it was slightly out of date at the time of writing, so I don't recommend this just yet. If you're on Linux you can run the manual installer easily enough.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ curl -O https://download.clojure.org/install/linux-install-1.9.0.326.sh
$ sudo bash linux-install-1.9.0.326.sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To update, use the package manager you used for the installation or find the latest Linux installer URL on the &lt;a href='https://clojure.org/guides/getting_started'&gt;getting started&lt;/a&gt; page.&lt;/p&gt;&lt;p&gt;You should now be able to drop into a Clojure REPL with one command. You can run &lt;code&gt;clojure&lt;/code&gt; or &lt;code&gt;clj&lt;/code&gt; in your terminal, the latter has a slightly better editing experience but requires you to have &lt;code&gt;rlwrap&lt;/code&gt; installed.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj
Clojure 1.9.0
user=&amp;gt; &amp;#40;+ 10 15&amp;#41;
25
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;initial&amp;#95;files&quot;&gt;Initial files&lt;/h2&gt;&lt;p&gt;Presuming our project is called &lt;code&gt;hey&lt;/code&gt;, let's go ahead and create these directories and files:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ mkdir -p hey/{src/hey,test/hey}
$ cd hey
$ touch src/hey/core.clj test/hey/core&amp;#95;test.clj
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This provides us with the following directory structure:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ tree
.
â”œâ”€â”€ src
â”‚Â Â  â””â”€â”€ hey
â”‚Â Â      â””â”€â”€ core.clj
â””â”€â”€ test
    â””â”€â”€ hey
        â””â”€â”€ core&amp;#95;test.clj

4 directories, 2 files
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let's insert some content into these files:&lt;/p&gt;&lt;h3 id=&quot;src/hey/core.clj&quot;&gt;src/hey/core.clj&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns hey.core&amp;#41;

&amp;#40;defn -main &amp;#91;&amp;#93;
  &amp;#40;println &amp;quot;Hello, World!&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;test/hey/core&amp;#95;test.clj&quot;&gt;test/hey/core&amp;#95;test.clj&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns hey.core-test
  &amp;#40;:require &amp;#91;clojure.test :as t&amp;#93;
            &amp;#91;hey.core :as sut&amp;#93;&amp;#41;&amp;#41;

&amp;#40;t/deftest basic-tests
  &amp;#40;t/testing &amp;quot;it says hello to everyone&amp;quot;
    &amp;#40;t/is &amp;#40;= &amp;#40;with-out-str &amp;#40;sut/-main&amp;#41;&amp;#41; &amp;quot;Hello, World!\n&amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The main namespace simply prints &quot;Hello, World!&quot; when executed and the test confirms that functionality.&lt;/p&gt;&lt;h2 id=&quot;running&amp;#95;your&amp;#95;code&quot;&gt;Running your code&lt;/h2&gt;&lt;p&gt;Now that we have a bare bones program and test file in our project directory, we're probably going to want to run it. We can do that with the Clojure CLI, go ahead and execute the following:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj -m hey.core
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You should see &quot;Hello, World!&quot; printed in your terminal. Let's try jumping into a REPL so we can interact with our code directly:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj
Clojure 1.9.0
user=&amp;gt; &amp;#40;load &amp;quot;hey/core&amp;quot;&amp;#41;
nil
user=&amp;gt; &amp;#40;in-ns 'hey.core&amp;#41;
#object&amp;#91;clojure.lang.Namespace 0x2072acb2 &amp;quot;hey.core&amp;quot;&amp;#93;
hey.core=&amp;gt; &amp;#40;-main&amp;#41;
Hello, World!
nil
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If your editor supports Clojure, you can probably connect a REPL and interact with your code through there too. With spacemacs I would type &lt;code&gt;,'&lt;/code&gt; to &quot;jack in&quot; with CIDER. I can then use &lt;code&gt;,ee&lt;/code&gt; to evaluate expressions as I work.&lt;/p&gt;&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;&lt;p&gt;We have a test file but no way to run it. We could create our own test runner namespace that executed &lt;code&gt;clojure.test/run-all-tests&lt;/code&gt;, but that requires telling it about every testing namespace we have in our project. It gets tedious after a while, so let's get something that does it for us.&lt;/p&gt;&lt;p&gt;Create a file called &lt;code&gt;deps.edn&lt;/code&gt; at the top of your project and add the following to it:&lt;/p&gt;&lt;h3 id=&quot;deps.edn&quot;&gt;deps.edn&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:deps
 {org.clojure/clojure {:mvn/version &amp;quot;1.9.0&amp;quot;}}

 :aliases
 {:test
  {:extra-paths &amp;#91;&amp;quot;test&amp;quot;&amp;#93;
   :extra-deps
   {com.cognitect/test-runner {:git/url &amp;quot;git@github.com:cognitect-labs/test-runner&amp;quot;
                               :sha &amp;quot;5f2b5c2efb444df76fb5252102b33f542ebf7f58&amp;quot;}}
   :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;cognitect.test-runner&amp;quot;&amp;#93;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let's break this down:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;:deps&lt;/code&gt; is where we specify our dependencies, right now all we're depending on is Clojure 1.9.0.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:aliases&lt;/code&gt; is where we specify special overrides that we can apply with the &lt;code&gt;-A&lt;/code&gt; argument to the CLI.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:test&lt;/code&gt; is the name of our alias, it adds the &lt;code&gt;test&lt;/code&gt; directory to the paths list and &lt;code&gt;com.cognitect/test-runner&lt;/code&gt; to the dependencies.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:main-opts&lt;/code&gt; instructs Clojure that we want these arguments applied when the alias is active. In this case, we're using &lt;code&gt;-m&lt;/code&gt; to specify which namespace to execute.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The usage of &lt;code&gt;deps.edn&lt;/code&gt; is documented further in &lt;a href='https://clojure.org/guides/deps_and_cli'&gt;the deps guide&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;This will discover and run our test for us, let's run it now:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj -Atest

Running tests in #{&amp;quot;test&amp;quot;}

Testing hey.core-test

Ran 1 tests containing 1 assertions.
0 failures, 0 errors.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Hopefully you see the same success message as myself. You can see that we applied the values specified in our alias with the &lt;code&gt;-Atest&lt;/code&gt; argument.&lt;/p&gt;&lt;h2 id=&quot;building&amp;#95;executable&amp;#95;jars&quot;&gt;Building executable jars&lt;/h2&gt;&lt;p&gt;In this section we're going to build an &quot;uberjar&quot; containing your application alongside all of the dependencies it requires to run.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; You only need to bother with uberjars if you're writing an application you wish to deploy and run somewhere. If you're building a library for others to depend on you probably won't need this. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Compiling your project into an uberjar will involve similar steps to getting your tests running, we're going to add another alias with another dependency which does the job for us.&lt;/p&gt;&lt;p&gt;Go ahead and add this new alias to the &lt;code&gt;:aliases&lt;/code&gt; section of your &lt;code&gt;deps.edn&lt;/code&gt; file, next to the &lt;code&gt;:test&lt;/code&gt; alias:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:uberjar
{:extra-deps
 {pack/pack.alpha
  {:git/url &amp;quot;git@github.com:juxt/pack.alpha.git&amp;quot;
   :sha     &amp;quot;e6d0691c5f58135e1ef6fb1c9dda563611d36205&amp;quot;}}
 :main-opts &amp;#91;&amp;quot;-m&amp;quot; &amp;quot;mach.pack.alpha.capsule&amp;quot; &amp;quot;deps.edn&amp;quot; &amp;quot;dist/hey.jar&amp;quot;&amp;#93;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now build a jar that we can execute directly through the &lt;code&gt;java&lt;/code&gt; program, without the Clojure CLI:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj -Auberjar
$ java -jar dist/hey.jar # Drops us into a Clojure REPL.
$ java -jar dist/hey.jar -m hey.core # Executes our &amp;quot;Hello, World!&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Please note that your code has not been AOT (ahead of time) compiled, it's still just plain Clojure that's compiled as and when it's required at run time. This can mean very slightly slower startup times when you're working with a large codebase.&lt;/p&gt;&lt;p&gt;If this becomes an issue for you you'll have to work out how to perform AOT compilation as you build your uberjar. By then, pack may even support it as a core feature.&lt;/p&gt;&lt;h2 id=&quot;publishing&amp;#95;to&amp;#95;clojars&quot;&gt;Publishing to Clojars&lt;/h2&gt;&lt;p&gt;In this section we're going to publish a small jar file to &lt;a href='https://clojars.org/'&gt;Clojars&lt;/a&gt; containing only your source code, we'll be using maven to perform the deploy.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; This is intended for libraries that others will depend on and use, you won't need to worry about this section if you're building an application you'll be running. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;First, we're going to add your Clojars login to &lt;code&gt;&amp;#126;/.m2/settings.xml&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;settings&amp;gt;
  &amp;lt;servers&amp;gt;
    &amp;lt;server&amp;gt;
      &amp;lt;id&amp;gt;clojars&amp;lt;/id&amp;gt;
      &amp;lt;username&amp;gt;username&amp;lt;/username&amp;gt;
      &amp;lt;password&amp;gt;password&amp;lt;/password&amp;gt;
    &amp;lt;/server&amp;gt;
  &amp;lt;/servers&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we're going to generate your base &lt;code&gt;pom.xml&lt;/code&gt; file, you should run this command whenever you're going to publish so the dependencies get updated:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ clj -Spom
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here's my example version, I've annotated each section. There's some you'll want to change as well as a couple of parts you'll want to add and update:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

  &amp;lt;!-- Here by default, but will need updating --&amp;gt;
  &amp;lt;groupId&amp;gt;org.clojars.olical&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;hey&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.1.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;name&amp;gt;hey&amp;lt;/name&amp;gt;

  &amp;lt;!-- Here by default, updated by `clj -Spom` --&amp;gt;
  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.clojure&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;clojure&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.9.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;
  &amp;lt;build&amp;gt;
    &amp;lt;sourceDirectory&amp;gt;src&amp;lt;/sourceDirectory&amp;gt;

    &amp;lt;!-- Essential for bundling your source files into the JAR --&amp;gt;
    &amp;lt;resources&amp;gt;
      &amp;lt;resource&amp;gt;
        &amp;lt;directory&amp;gt;src&amp;lt;/directory&amp;gt;
      &amp;lt;/resource&amp;gt;
    &amp;lt;/resources&amp;gt;
  &amp;lt;/build&amp;gt;
  &amp;lt;repositories&amp;gt;
    &amp;lt;repository&amp;gt;
      &amp;lt;id&amp;gt;clojars&amp;lt;/id&amp;gt;
      &amp;lt;url&amp;gt;https://clojars.org/repo&amp;lt;/url&amp;gt;
    &amp;lt;/repository&amp;gt;
  &amp;lt;/repositories&amp;gt;

  &amp;lt;!-- Essential for pushing to Clojars --&amp;gt;
  &amp;lt;distributionManagement&amp;gt;
    &amp;lt;repository&amp;gt;
      &amp;lt;id&amp;gt;clojars&amp;lt;/id&amp;gt;
      &amp;lt;name&amp;gt;Clojars repository&amp;lt;/name&amp;gt;
      &amp;lt;url&amp;gt;https://clojars.org/repo&amp;lt;/url&amp;gt;
    &amp;lt;/repository&amp;gt;
  &amp;lt;/distributionManagement&amp;gt;

  &amp;lt;!-- Optional extras for Clojars --&amp;gt;
  &amp;lt;description&amp;gt;Just a Hello, World!&amp;lt;/description&amp;gt;
  &amp;lt;url&amp;gt;https://github.com/Olical/clojure-hey-example&amp;lt;/url&amp;gt;
  &amp;lt;licenses&amp;gt;
    &amp;lt;license&amp;gt;
      &amp;lt;name&amp;gt;Unlicense&amp;lt;/name&amp;gt;
      &amp;lt;url&amp;gt;https://unlicense.org/&amp;lt;/url&amp;gt;
    &amp;lt;/license&amp;gt;
  &amp;lt;/licenses&amp;gt;
  &amp;lt;scm&amp;gt;
    &amp;lt;url&amp;gt;https://github.com/Olical/clojure-hey-example&amp;lt;/url&amp;gt;
  &amp;lt;/scm&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now tell maven to build and deploy a jar to Clojars:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ mvn deploy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A lot of this information comes from &lt;a href='https://github.com/clojars/clojars-web/wiki/Pushing'&gt;Clojar's guide to pushing&lt;/a&gt; and &lt;a href='https://maven.apache.org/guides/mini/guide-3rd-party-jars-remote.html'&gt;Maven's guide to deploying 3rd party jars&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;If everything went to plan, your Clojars account should now contain a fresh new jar. Note that this is &lt;i&gt;not&lt;/i&gt; an uberjar, it only contains your source files and dependency information, not the actual dependencies themselves. The dependencies will be resolved by a tool such as the Clojure CLI.&lt;/p&gt;&lt;h2 id=&quot;ergonomics&quot;&gt;Ergonomics&lt;/h2&gt;&lt;p&gt;As it stands, to deploy our jar to Clojars we'll want to take the following steps:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Update the version number in our &lt;code&gt;pom.xml&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;Run the tests with &lt;code&gt;clj -Atest&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;Run &lt;code&gt;clj -Spom&lt;/code&gt; to update our &lt;code&gt;pom.xml&lt;/code&gt; with any dependency changes.&lt;/li&gt;&lt;li&gt;Run &lt;code&gt;mvn deploy&lt;/code&gt;. &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This isn't particularly catchy, so we'll wrap everything we've seen so far in a pretty little &lt;code&gt;Makefile&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;makefile&quot;&gt;.PHONY: run test uberjar deploy

run:
	clj -m hey.core

test:
	clj -Atest

uberjar:
	clj -Auberjar

deploy: test
	clj -Spom
	mvn deploy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now all you need to do when you wish to deploy is bump the version number in your &lt;code&gt;pom.xml&lt;/code&gt; and execute &lt;code&gt;make deploy&lt;/code&gt;.&lt;/p&gt;&lt;h2 id=&quot;thanks!&quot;&gt;Thanks!&lt;/h2&gt;&lt;p&gt;I really hope this post has helped you out! You can find the example project I built during the writing of this post at &lt;a href='https://github.com/Olical/clojure-hey-example'&gt;github.com/Olical/clojure-hey-example&lt;/a&gt; and the &lt;a href='https://clojars.org/org.clojars.olical/hey/versions/2.1.0-SNAPSHOT'&gt;Clojars page here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Happy Clojuring!&lt;/p&gt;
</description>
<pubDate>
Mon, 26 Feb 2018 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://oli.me.uk/2017-10-27-hello-world/
</guid>
<link>
https://oli.me.uk/2017-10-27-hello-world/
</link>
<title>
Hello, World!
</title>
<description>
&lt;p&gt;I've, once again, migrated my blog onto another platform. This time I've gone from WordPress on my own Linode to &lt;a href=&quot;&quot;&gt;Cryogen&lt;/a&gt; on GitHub pages. This means a few things:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;I no longer need to worry about running my own server, even though Linode is fantastic. I just don't want to maintain anything, especially WordPress.&lt;/li&gt;&lt;li&gt;I can blog with a Clojure based platform and integrate &lt;a href=&quot;&quot;&gt;Klipse&lt;/a&gt; easily for interactive lispy posts.&lt;/li&gt;&lt;li&gt;I can write my posts in markdown with Emacs and keep it all on &lt;a href=&quot;https://github.com/Olical/olical.github.io&quot;&gt;GitHub&lt;/a&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;the_migration&quot;&gt;The migration&lt;/h2&gt; &lt;p&gt;I wanted to start fresh since my old blog is full of so many topics that I do not feel reflect my true interests anymore, so here I am with a blank slate. Luckily I found a way to keep my WordPress site exactly how it was so as not to break a single URL without running WordPress itself.&lt;/p&gt;&lt;p&gt;I used &lt;a href=&quot;https://en-gb.wordpress.org/plugins/simply-static/&quot;&gt;Simply Static&lt;/a&gt; to generate a snapshot of my entire blog which I could then merge into my GitHub pages repositories top level. This means every URL that used to work with my original blog will work with this one.&lt;/p&gt;&lt;p&gt;I don't promote my old posts through this anymore, but they're still there, I even preserved &lt;a href=&quot;https://oli.me.uk/wp-index.html&quot;&gt;the original homepage&lt;/a&gt;.&lt;/p&gt;&lt;h2 id=&quot;the_payoff&quot;&gt;The payoff&lt;/h2&gt;&lt;p&gt;I think it was worth it since I no longer have to run a server and I can do things like this.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-scheme nohighlight&quot;&gt;(define (add a b)
  (if (= b 0)
    a
    (add (+ a 1) (- b 1))))
    
(add 10 20)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I also did this entire migration today while on trains and in cars over mobile internet, which was fun.&lt;/p&gt;
</description>
<pubDate>
Fri, 27 Oct 2017 00:00:00 +0100
</pubDate>
</item>
</channel>
</rss>
